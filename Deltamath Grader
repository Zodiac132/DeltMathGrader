# -*- coding: utf-8 -*- # Ensure UTF-8 encoding is recognized

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
import tkinter.simpledialog
import os
import subprocess # Needed for auto-install and opening folders
import sys # Needed for sys.executable and platform checks
import re
import threading
import time
import shlex # Used for parsing drag/drop paths
import webbrowser # Required to open web links
from pathlib import Path # Used for path manipulation
import importlib # Needed to check module availability dynamically
from datetime import date, datetime # For finding today's files

# --- Function to Check and Install Dependencies ---
# (No changes needed in this function)
def check_and_install_dependencies(root_window=None):
    """Checks for required and optional dependencies and prompts for installation."""
    required_packages = {
        "pandas": "pandas",
        "fuzzywuzzy": "fuzzywuzzy[speedup]", # Include speedup extras
        "openpyxl": "openpyxl" # Essential for pandas .xlsx support
    }
    optional_packages = {
        "keyboard": "keyboard", # For Auto Grade trigger
        "pyautogui": "pyautogui", # For Auto Grade typing
        "requests": "requests", # For Feedback feature
        "tkinterdnd2": "tkinterdnd2" # For Drag and Drop
    }
    all_packages = {**required_packages, **optional_packages}
    missing_packages = []
    installation_failed = []

    print("--- Checking Dependencies ---")
    for import_name, install_name in all_packages.items():
        try:
            importlib.import_module(import_name)
            print(f"[ OK ] {import_name} found.")
        except ImportError:
            print(f"[MISSING] {import_name} not found.")
            missing_packages.append((import_name, install_name))

    if not missing_packages:
        print("--- All dependencies are satisfied ---")
        return True # All good

    # Create a temporary minimal Tk window if none is provided (for early checks)
    temp_root = None
    if root_window is None and missing_packages:
        try:
            temp_root = tk.Tk()
            temp_root.withdraw() # Hide the temporary window
            root_window = temp_root
        except tk.TclError:
             print("ERROR: Could not initialize Tkinter for prompts. Cannot install missing packages automatically.")
             return False # Cannot proceed without Tkinter for prompts

    # Prompt user for installation
    install_prompt_message = "The following packages are missing or failed to import:\n\n"
    install_prompt_message += "\n".join([f"- {imp} ({'required' if imp in required_packages else 'optional'})" for imp, _ in missing_packages])
    install_prompt_message += "\n\nDo you want to attempt automatic installation using pip?"

    # Make sure we have a valid window to parent the messagebox
    parent_window = root_window if root_window and root_window.winfo_exists() else None

    if not parent_window and not sys.stdout.isatty(): # No GUI window and not interactive terminal
         print("ERROR: Cannot prompt for installation in non-interactive mode.")
         return False # Cannot proceed

    should_install = False
    if parent_window:
         should_install = messagebox.askyesno(
             "Install Missing Packages?",
             install_prompt_message,
             parent=parent_window # Use the provided or temporary root
         )
    elif sys.stdout.isatty(): # Ask in console if no GUI but interactive
         try:
            response = input(install_prompt_message + " (y/n): ").lower()
            should_install = response == 'y'
         except EOFError: # Handle non-interactive environments piping input
            print("Warning: Could not read response from input.")
            should_install = False

    if should_install:
        print("--- Attempting installation ---")
        # Use a set to keep track of unique failures
        installation_failed_set = set()
        for import_name, install_name in missing_packages:
            # Skip if already failed
            if import_name in installation_failed_set: continue

            print(f"Installing {install_name}...")
            try:
                # Use sys.executable to ensure pip is called for the correct Python env
                # Use -q for quieter output, capture stderr for better error messages
                process = subprocess.run(
                    [sys.executable, '-m', 'pip', 'install', '-q', install_name],
                    check=True, capture_output=True, text=True, encoding='utf-8'
                )
                print(f"Successfully installed {install_name}.")
            except subprocess.CalledProcessError as e:
                error_details = e.stderr or e.stdout or "No error output captured."
                error_msg = f"Failed to install {install_name}.\nCommand: '{' '.join(e.cmd)}'\nError: {error_details}\n\nPlease try installing manually."
                print(f"ERROR: {error_msg}")
                if parent_window: messagebox.showerror("Installation Failed", error_msg, parent=parent_window)
                installation_failed_set.add(import_name)
            except FileNotFoundError:
                error_msg = f"Failed to install {install_name}.\n'pip' command not found ({sys.executable} -m pip).\nEnsure Python and pip are correctly installed and in your system's PATH."
                print(f"ERROR: {error_msg}")
                if parent_window: messagebox.showerror("Installation Failed", error_msg, parent=parent_window)
                installation_failed_set.add(import_name)
                break # Stop trying if pip isn't found
            except Exception as e:
                 error_msg = f"An unexpected error occurred while installing {install_name}: {e}"
                 print(f"ERROR: {error_msg}")
                 if parent_window: messagebox.showerror("Installation Failed", error_msg, parent=parent_window)
                 installation_failed_set.add(import_name)

        installation_failed = list(installation_failed_set) # Convert back to list

        # Check if any *required* packages failed installation
        failed_required = [imp for imp in installation_failed if imp in required_packages]
        if failed_required:
            msg = f"Failed to install required packages: {', '.join(failed_required)}.\nThe application cannot continue.\nPlease install them manually and restart."
            print(f"FATAL ERROR: {msg}")
            if parent_window: messagebox.showerror("Critical Error", msg, parent=parent_window)
            if temp_root: temp_root.destroy()
            sys.exit(f"Exiting due to missing required packages: {', '.join(failed_required)}") # Exit script

        if installation_failed: # Only optional failed if we reach here
             msg = f"Failed to install some optional packages: {', '.join(installation_failed)}.\nRelated features might be disabled.\nYou can try installing them manually."
             print(f"WARNING: {msg}")
             if parent_window: messagebox.showwarning("Optional Installation Failed", msg, parent=parent_window)

        print("--- Dependency check finished ---")
        # Return True only if *all* missing packages were installed successfully
        all_installed_successfully = len(installation_failed) == 0

    else: # User chose not to install
        print("--- Installation skipped by user ---")
        failed_required = [imp for imp, _ in missing_packages if imp in required_packages]
        if failed_required:
             msg = f"Required packages are missing: {', '.join(failed_required)} and installation was skipped.\nThe application cannot continue."
             print(f"FATAL ERROR: {msg}")
             if parent_window: messagebox.showerror("Critical Error", msg, parent=parent_window)
             if temp_root: temp_root.destroy()
             sys.exit(f"Exiting due to missing required packages: {', '.join(failed_required)}") # Exit script
        else:
            # Only optional packages missing and user skipped
            missing_optional = [imp for imp, _ in missing_packages if imp in optional_packages]
            if missing_optional:
                msg = f"Optional packages are missing: {', '.join(missing_optional)} and installation was skipped.\nRelated features will be disabled."
                print(f"WARNING: {msg}")
                if parent_window: messagebox.showwarning("Features Disabled", msg, parent=parent_window)
            all_installed_successfully = False # Indicate optional features might be missing

    if temp_root:
        temp_root.destroy()

    # Rerun import check after attempting install to verify
    final_missing = []
    print("--- Verifying dependencies post-installation attempt ---")
    for import_name, install_name in all_packages.items():
         try:
             importlib.import_module(import_name)
             print(f"[ OK ] {import_name} verified.")
         except ImportError:
             print(f"[FAILED] {import_name} still missing after installation attempt.")
             final_missing.append(import_name)

    # Final critical check for required packages
    missing_required_final = [m for m in final_missing if m in required_packages]
    if missing_required_final:
         msg = f"Required packages still missing after installation attempt: {', '.join(missing_required_final)}.\nApplication cannot run."
         print(f"FATAL ERROR: {msg}")
         if parent_window: messagebox.showerror("Critical Error", msg, parent=parent_window)
         sys.exit(f"Exiting due to missing required packages: {', '.join(missing_required_final)}")

    # Return True if all required are present, even if some optional failed
    print("--- Dependency verification complete ---")
    return True

# --- Attempt dependency check and installation BEFORE full GUI setup ---
check_and_install_dependencies()

# --- Now Import Libraries (with flags for optional ones) ---
try: import pandas as pd
except ImportError: print("FATAL ERROR: pandas failed to import even after installation check."); sys.exit(1)
try: from fuzzywuzzy import fuzz
except ImportError: print("FATAL ERROR: fuzzywuzzy failed to import even after installation check."); sys.exit(1)
try: import openpyxl # Although used by pandas, import to confirm
except ImportError: print("FATAL ERROR: openpyxl failed to import even after installation check."); sys.exit(1)

keyboard_available = False
pyautogui_available = False
requests_available = False
tkinterdnd2_available = False
tk_class = tk.Tk # Default to standard Tk
DND_FILES = None # Default DND constant

try:
    import keyboard
    keyboard_available = True
    print("Optional: keyboard loaded.")
except ImportError:
    print("Optional: keyboard not found.")
except Exception as e:
     print(f"Optional: Error loading keyboard - {e}")

try:
    import pyautogui
    pyautogui_available = True
    print("Optional: pyautogui loaded.")
except ImportError:
    print("Optional: pyautogui not found.")
except Exception as e:
     print(f"Optional: Error loading pyautogui - {e}")

try:
    import requests
    requests_available = True
    print("Optional: requests loaded.")
except ImportError:
    print("Optional: requests not found.")

try:
    from tkinterdnd2.TkinterDnD import TkinterDnD
    from tkinterdnd2 import DND_FILES
    tk_class = TkinterDnD
    tkinterdnd2_available = True
    print("Optional: tkinterdnd2 found, drag-and-drop enabled.")
except ImportError:
    print("Optional: tkinterdnd2 library not found. Drag-and-drop disabled.")
except Exception as e:
     print(f"Optional: Error loading tkinterdnd2 - {e}")

# --- Configuration ---
CLASS_GRADE_SHEET_URL = "https://gradebook.dadeschools.net/Pinnacle/Gradebook/"
DATA_SUBFOLDER_NAME = "DeltaMathGraderData"
DISCORD_WEBHOOK_URL = "https://discord.com/api/webhooks/1362001033387053096/2wOn2D3p0GUruGEGlmriiijREU-wD869RL3U0k-tbni9mQ21z0NDPPI5y0ksGfnWJ9ty" if requests_available else None

# --- Global Variables ---
excel_filepath = None
editor_current_filename = None
editor_save_scheduled = None
root = None # Will be assigned later
is_dragging_over = False
excel_file_source_is_drop = False # Flag to track if last selection was via drop

# --- Helper Functions ---
# (get_data_folder, get_period_filepath, load_names_from_file, read_text_file, save_text_file - NO CHANGES)
def get_data_folder():
    """Gets the path to the application's data folder, creating it if necessary."""
    try:
        home_dir = Path.home()
        possible_docs_paths = [ home_dir / "Documents", home_dir / "My Documents" ]
        docs_dir = next((path for path in possible_docs_paths if path.is_dir()), home_dir)
        if docs_dir == home_dir and not any(p.is_dir() for p in possible_docs_paths):
             print("Warning: Standard 'Documents' folder not found, using home directory for data.")
        data_dir = docs_dir / DATA_SUBFOLDER_NAME
        data_dir.mkdir(parents=True, exist_ok=True)
        return str(data_dir)
    except Exception as e:
        msg = f"Could not create/access data folder in Documents or Home:\n{e}"
        print(f"ERROR: {msg}")
        fallback_dir = Path.cwd() / DATA_SUBFOLDER_NAME
        try:
             fallback_dir.mkdir(parents=True, exist_ok=True)
             print(f"Warning: Using fallback data folder: {fallback_dir}")
             if root and root.winfo_exists():
                  messagebox.showwarning("Folder Warning", f"Using fallback data folder:\n{fallback_dir}\n(Could not use Documents/Home)", parent=root)
             return str(fallback_dir)
        except Exception as fallback_e:
             final_msg = f"FATAL: Could not create data folder anywhere:\n{fallback_e}"
             print(final_msg)
             if root and root.winfo_exists(): messagebox.showerror("Fatal Folder Error", final_msg, parent=root)
             return os.getcwd()

def get_period_filepath(period_num):
    """Constructs the full path for a period's name list file."""
    return os.path.join(get_data_folder(), f"period{period_num}.txt")

def load_names_from_file(filepath):
    """Reads names from a text file, one per line."""
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            names = [line.strip() for line in f if line.strip()]
        return names
    except FileNotFoundError:
        return []
    except Exception as e:
        if root and root.winfo_exists():
            messagebox.showerror("Error", f"Error reading {os.path.basename(filepath)}:\n{e}", parent=root)
        return []

def read_text_file(filepath):
    """Reads the entire content of a text file."""
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            return f.read()
    except FileNotFoundError:
        return ""
    except Exception as e:
        if root and root.winfo_exists():
            messagebox.showerror("Error", f"Error reading {os.path.basename(filepath)}:\n{e}", parent=root)
        return ""

def save_text_file(filepath, content, show_success=True):
    """Saves text content to a file, creating directories if needed."""
    try:
        os.makedirs(os.path.dirname(filepath), exist_ok=True)
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(content)
        if show_success and root and root.winfo_exists():
             try:
                 data_folder_path = Path(get_data_folder())
                 file_path_obj = Path(filepath)
                 display_name = os.path.join("...", data_folder_path.name, file_path_obj.name)
             except Exception:
                 display_name = os.path.basename(filepath)
             root.after(500, lambda name=display_name: messagebox.showinfo("Save Successful", f"Saved {name}", parent=root))
        return True
    except Exception as e:
        error_msg = f"Error saving {os.path.basename(filepath)}:\n{e}"
        print(f"ERROR: {error_msg}")
        if root and root.winfo_exists(): messagebox.showerror("Save Error", error_msg, parent=root)
        return False

def find_downloads_folder():
    """Attempts to find the user's Downloads folder."""
    try:
        home = Path.home()
        possible_paths = [
            home / "Downloads",
            home / "downloads",
        ]
        if sys.platform == "win32":
            onedrive_downloads = Path(os.environ.get('USERPROFILE', '')) / 'OneDrive' / 'Downloads'
            if onedrive_downloads.is_dir():
                 possible_paths.insert(0, onedrive_downloads)

        for path in possible_paths:
            if path.is_dir():
                print(f"Found Downloads folder: {path}")
                return str(path)
    except Exception as e:
         print(f"Error finding Downloads folder: {e}")

    print("Warning: Could not automatically determine Downloads folder. Falling back.")
    fallback_path = Path.home() / "Downloads"
    if fallback_path.is_dir():
        print(f"Using fallback Downloads path: {fallback_path}")
        return str(fallback_path)
    else:
        print(f"Error: Fallback Downloads path '{fallback_path}' does not exist.")
        if root and root.winfo_exists(): messagebox.showerror("Error", "Could not find or access the Downloads folder.", parent=root)
        return None

# --- FUNCTION UPDATED WITH MORE EXPLICIT LOGGING ---
def find_excel_file_automatically():
    """
    Looks for .xlsx files modified TODAY in Downloads.
    - If one is found, returns its path.
    - If multiple are found, prompts the user to choose.
    - If none are found, returns None.
    """
    downloads_path_str = find_downloads_folder()
    if not downloads_path_str:
        # Error shown by find_downloads_folder
        return None

    downloads_path = Path(downloads_path_str)
    # --- Get today's date ---
    today = date.today()
    print(f"\n--- Searching for Excel files modified TODAY ({today}) in: {downloads_path} ---")

    # --- Find files modified TODAY ---
    todays_excel_files = []
    try:
        file_list = list(downloads_path.iterdir())
        print(f"Found {len(file_list)} total items in directory. Checking modification dates against TODAY ({today})...") # Emphasize Today
        for item in file_list:
            if item.is_file() and item.suffix.lower() == ".xlsx" and not item.name.startswith("~"):
                try:
                    mtime_ts = item.stat().st_mtime
                    mdate = date.fromtimestamp(mtime_ts) # Get modification date
                    is_today = (mdate == today) # Explicit comparison result

                    # --- Log comparison ---
                    print(f"  Checking: {item.name} | Mod Date: {mdate} | Today: {today} | Is Today? {is_today}")

                    # --- Check if modification date is today ---
                    if is_today:
                        todays_excel_files.append((str(item), mtime_ts)) # Store path and timestamp
                        mtime_str = datetime.fromtimestamp(mtime_ts).strftime('%Y-%m-%d %H:%M:%S')
                        print(f"    -> [MATCH FOUND] Adding {item.name} (Modified: {mtime_str})")

                except FileNotFoundError:
                    print(f"  [Skipped] File disappeared while checking: {item.name}")
                except OSError as e:
                    print(f"  [Skipped] Could not get stats for {item.name}: {e}")
                except Exception as e:
                     print(f"  [Skipped] Unexpected error processing file {item.name}: {e}")

    except FileNotFoundError:
        print(f"ERROR: Downloads folder not found during scan: {downloads_path}")
        if root and root.winfo_exists(): messagebox.showerror("Error", f"Downloads folder not found during scan:\n{downloads_path}", parent=root)
        return None
    except PermissionError:
        print(f"ERROR: Permission denied reading Downloads folder: {downloads_path}")
        if root and root.winfo_exists(): messagebox.showerror("Error", f"Permission denied reading Downloads folder:\n{downloads_path}", parent=root)
        return None
    except Exception as e:
        print(f"ERROR: Error reading Downloads folder contents: {e}")
        if root and root.winfo_exists(): messagebox.showerror("Error", f"Error reading Downloads folder contents:\n{e}", parent=root)
        return None

    # --- Process the results ---
    num_found = len(todays_excel_files)

    if num_found == 0:
        print(f"--- No suitable .xlsx files modified today ({today}) found in Downloads. ---")
        # Let the calling function decide whether to show an error message
        return None # No files found from today

    elif num_found == 1:
        selected_path = todays_excel_files[0][0]
        print(f"--- Automatically selected the only Excel file from today: {os.path.basename(selected_path)} ---")
        return selected_path

    else: # Multiple files found today
        print(f"--- Found {num_found} Excel files modified today. Sorting by time and prompting user... ---")
        # Sort by modification time (newest first) - index 1 is the timestamp
        todays_excel_files.sort(key=lambda item: item[1], reverse=True)

        # Build the prompt message
        prompt = f"Multiple ({num_found}) Excel files from today found in Downloads.\n\nSelect the file to use:\n\n"
        for i, (fpath, ftime) in enumerate(todays_excel_files):
            # Format time nicely for the prompt
            time_str = datetime.fromtimestamp(ftime).strftime('%I:%M:%S %p') # e.g., 03:45:10 PM
            prompt += f"{i+1}. {os.path.basename(fpath)} ({time_str})\n"

        # Ask the user
        parent_win = root if root and root.winfo_exists() else None
        choice_str = tkinter.simpledialog.askstring("Select Today's Excel File", prompt, parent=parent_win)

        if choice_str is None:
            print("--- User cancelled file selection. ---")
            return None # User cancelled

        # Validate the choice
        try:
            choice_idx = int(choice_str) - 1 # Convert to 0-based index
            if 0 <= choice_idx < num_found:
                selected_path = todays_excel_files[choice_idx][0]
                print(f"--- User selected: {os.path.basename(selected_path)} ---")
                return selected_path
            else:
                raise ValueError("Choice out of range")
        except (ValueError, TypeError):
            msg = f"Invalid selection ('{choice_str}'). Please enter a number between 1 and {num_found}."
            print(f"ERROR: {msg}")
            if parent_win: messagebox.showerror("Invalid Input", msg, parent=parent_win)
            return None # Invalid choice


# --- Name Matching / Processing ---
# (find_exact_match, find_best_match, process_name - NO CHANGES)
def find_exact_match(name_to_find, df, first_name_column, last_name_column):
    """Finds an exact match (case-insensitive) for a name in the DataFrame."""
    name_lower = name_to_find.lower().strip()
    for index, row in df.iterrows():
        first = str(row.get(first_name_column, '')) if pd.notna(row.get(first_name_column)) else ''
        last = str(row.get(last_name_column, '')) if pd.notna(row.get(last_name_column)) else ''
        full_name = (first.strip() + ' ' + last.strip()).strip()
        if name_lower == full_name.lower():
            return row, index
    return None, None

def find_best_match(name_to_find, df, first_name_column, last_name_column, threshold=60):
    """Finds the best fuzzy match for a name above a given threshold."""
    best_match_row, best_ratio, best_index = None, 0, None
    name_lower = name_to_find.lower().strip()
    matched_df_name = None
    for index, row in df.iterrows():
        first = str(row.get(first_name_column, '')) if pd.notna(row.get(first_name_column)) else ''
        last = str(row.get(last_name_column, '')) if pd.notna(row.get(last_name_column)) else ''
        full_name = (first.strip() + ' ' + last.strip()).strip()
        full_name_lower = full_name.lower()
        if not full_name_lower: continue
        ratio = fuzz.token_sort_ratio(name_lower, full_name_lower)
        if ratio > best_ratio:
            best_ratio = ratio
            best_match_row = row
            best_index = index
            matched_df_name = full_name
    if best_ratio >= threshold:
        return best_match_row, best_ratio, best_index, matched_df_name
    return None, 0, None, None

def process_name(name, df, first_col, last_col, grade_col, use_interval, interval_pct):
    """Processes a single name: finds match, gets grade from specified column, applies interval logic."""
    exact_row, exact_idx = find_exact_match(name, df, first_col, last_col)
    grade_val, original_grade, match_type, details, target_idx = None, None, "Not Found", "", None
    found_name = name # Default to original name

    if exact_row is not None:
        target_idx = exact_idx
        grade_val = exact_row.get(grade_col) # Get grade from the SELECTED column
        match_type = "Exact Match"
        first = str(exact_row.get(first_col, '')).strip() if pd.notna(exact_row.get(first_col)) else ''
        last = str(exact_row.get(last_col, '')).strip() if pd.notna(exact_row.get(last_col)) else ''
        found_name = f"{first} {last}".strip()
    else:
        match_row, ratio, match_idx, matched_df_name = find_best_match(name, df, first_col, last_col)
        if match_row is not None:
            target_idx = match_idx
            grade_val = match_row.get(grade_col) # Get grade from the SELECTED column
            match_type = "Fuzzy Match"
            details = f"(Ratio: {ratio}%)"
            found_name = matched_df_name

    if pd.notna(grade_val):
        try:
            original_grade = float(grade_val)
            processed_grade = original_grade # Start with the original

            if use_interval:
                processed_grade = 100.0 if original_grade >= interval_pct else 0.0
                # Update the *passed-in* DataFrame copy if interval changed the grade
                if processed_grade != original_grade and target_idx is not None and target_idx in df.index:
                    # Use .loc for safe setting - requires index and column name
                    df.loc[target_idx, grade_col] = processed_grade # Update the specific grade column

            orig_str = f"{original_grade:.1f}%" if original_grade is not None else "N/A"
            proc_str = f"{processed_grade:.1f}%" if processed_grade is not None else "N/A"
            return f"{name} -> {found_name} | {proc_str} ({match_type} {details}, Original: {orig_str})"
        except (ValueError, TypeError):
             # Handle non-numeric grade values (e.g., "Complete")
             processed_grade_non_numeric = 0.0 # Default assumption
             original_value_str = str(grade_val).strip()

             if use_interval:
                 # Specific rule for "Complete" if interval grading is on
                 if original_value_str.lower() == 'complete':
                      processed_grade_non_numeric = 100.0
                 # Otherwise, non-numeric values become 0.0 under interval grading

                 # Update DataFrame if interval logic applies
                 if target_idx is not None and target_idx in df.index:
                     # Use .loc for safe setting
                     df.loc[target_idx, grade_col] = processed_grade_non_numeric
                 return f"{name} -> {found_name} | {processed_grade_non_numeric:.1f}% ({match_type} {details}, Original: '{original_value_str}')"
             else:
                 # If not using interval, just report the non-numeric value found
                 return f"{name} -> {found_name} | Non-Numeric ({match_type}, Value: '{original_value_str}')"
    else:
        # Grade value was NaN or missing in the Excel sheet for the matched row
        if match_type != "Not Found":
            return f"{name} -> {found_name} | Grade Missing ({match_type} {details})"
        else:
            # No match found at all
            return f"{name} | Grade Not Found (No Match)"

# --- Grade Typing / Other Utilities ---
# (extract_grades_from_output - NO CHANGES)
def extract_grades_from_output(filepath):
    """Extracts numerical grade values from the processed output file."""
    grades = []
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if not line or '|' not in line: continue
                try:
                    parts = line.split('|')
                    if len(parts) > 1:
                        percentage_part = parts[1].strip()
                        match = re.search(r"([\d.]+)\%?", percentage_part)
                        if match:
                            try:
                                grade_float = float(match.group(1))
                                formatted_grade = f"{grade_float:.1f}".replace('.0', '')
                                grades.append(formatted_grade)
                            except ValueError:
                                print(f"Warn: Could not convert grade value '{match.group(1)}' in line: {line}")
                        elif "Non-Numeric" in percentage_part:
                             print(f"Info: Skipping non-numeric grade in line: {line}")
                        elif "Grade Missing" in percentage_part or "Grade Not Found" in line:
                             print(f"Info: Skipping missing/not found grade in line: {line}")
                        else:
                            print(f"Warn: Could not extract numeric grade from part '{percentage_part}' in line: {line}")
                except Exception as e:
                    print(f"Warn: Error parsing line content: {line} - {e}")
    except FileNotFoundError:
        if root and root.winfo_exists(): messagebox.showerror("Error", f"Grade file not found:\n{filepath}", parent=root)
        return []
    except Exception as e:
        if root and root.winfo_exists(): messagebox.showerror("Error", f"Error reading grades file:\n{e}", parent=root)
        return []
    return grades

# --- UPDATED type_grades function ---
def type_grades(grades_list):
    """Types the extracted grades using pyautogui, hiding the main window during typing."""
    if not root or not root.winfo_exists(): return
    if not pyautogui_available:
        print("ERROR: pyautogui not available for typing grades.")
        if root and root.winfo_exists(): messagebox.showerror("Auto Grade Error", "PyAutoGUI library is missing or failed to load.\nCannot type grades.", parent=root)
        return
    if not grades_list:
        if root and root.winfo_exists(): messagebox.showwarning("Auto Grade", "No grades extracted to type.", parent=root)
        return

    print("Waiting for trigger...")
    trigger_received = False
    initial_state = root.state() # Remember if it was withdrawn already

    try:
        # --- Hide window more effectively ---
        print("Withdrawing main window...")
        root.after(0, root.withdraw)
        time.sleep(0.5) # Short pause for window manager to react

        # --- Trigger ---
        if keyboard_available:
            print("Press '*' key to begin typing.")
            keyboard.wait('*') # This blocks the current (typing) thread
            trigger_received = True
            print("Detected '*'.")
        else:
            # Need to temporarily show window for the messagebox prompt
            if root and root.winfo_exists():
                 print("Temporarily showing window for prompt...")
                 root.after(0, root.deiconify) # Make visible
                 root.after(100, root.attributes, '-topmost', True) # Bring to front
                 messagebox.showinfo("Auto Grade", "Keyboard library missing/failed.\n\nClick OK when the gradebook field is focused.", parent=root)
                 root.after(100, root.attributes, '-topmost', False) # Release topmost
                 # Hide window again immediately after prompt
                 root.after(150, root.withdraw)
                 time.sleep(0.3) # Small delay after prompt hiding
                 trigger_received = True
            else:
                 print("Cannot prompt user (no window). Typing cancelled.")
                 trigger_received = False

    except Exception as e:
        print(f"ERROR during trigger wait: {e}")
        if root and root.winfo_exists(): messagebox.showerror("Trigger Error", f"Failed waiting for trigger:\n{e}\n(Ensure script has permissions if needed)", parent=root)
        trigger_received = False
    # --- DO NOT restore or focus here ---

    if not trigger_received:
        print("Typing cancelled (no trigger or error).")
        # Ensure window is restored if trigger failed/cancelled
        try:
            if root and root.winfo_exists() and root.state() != initial_state :
                 print("Restoring window after cancelled trigger.")
                 root.after(0, root.deiconify)
        except tk.TclError: pass
        return

    print(f"Typing {len(grades_list)} grades...")
    try:
        # --- SIGNIFICANT DELAY before starting ---
        start_delay = 2.5 # Increased delay (seconds) - adjust if needed
        print(f"Waiting {start_delay} seconds before typing... Focus the gradebook NOW!")
        time.sleep(start_delay)

        # --- Typing Loop ---
        for i, grade in enumerate(grades_list):
            # Check if root window still exists before each action
            if not root or not root.winfo_exists():
                print(f"Window closed during typing at grade {i+1}. Aborting.")
                break

            # Check if user pressed Esc (requires keyboard library)
            if keyboard_available and keyboard.is_pressed('esc'):
                print("Escape key pressed. Aborting typing.")
                # Restore window *before* showing message
                if root and root.winfo_exists():
                    root.after(0, root.deiconify)
                    root.after(100, root.attributes, '-topmost', True)
                    messagebox.showwarning("Typing Aborted", "Typing stopped by user (Esc key).", parent=root)
                    root.after(100, root.attributes, '-topmost', False)
                break

            pyautogui.write(grade, interval=0.01) # Type faster if needed: interval=0.0
            time.sleep(0.05) # Short pause after typing
            pyautogui.press('enter') # Move to next field/confirm
            time.sleep(0.15) # Pause before typing next grade (adjust if needed for gradebook responsiveness)
        else:
            # Loop completed without break (no errors, no Esc)
            print("Finished typing grades.")
            # Restore window *before* showing final message
            if root and root.winfo_exists():
                print("Restoring window after successful typing.")
                root.after(0, root.deiconify)
            # Schedule final message box
            if root and root.winfo_exists():
                 # Make sure message appears on top
                 root.after(100, root.attributes, '-topmost', True)
                 messagebox.showinfo("Auto Grade", "Finished typing grades.", parent=root)
                 root.after(100, root.attributes, '-topmost', False)

    except Exception as e:
        error_msg = f"An error occurred during typing:\n{e}"
        print(f"ERROR: {error_msg}")
        # Restore window before showing error
        if root and root.winfo_exists():
             root.after(0, root.deiconify)
             root.after(100, root.attributes, '-topmost', True)
             messagebox.showerror("Typing Error", error_msg, parent=root)
             root.after(100, root.attributes, '-topmost', False)
    finally:
         # --- Final check to ensure window is restored ---
         # Use after to schedule restoration on the main thread safely
         def final_restore():
            try:
                if root and root.winfo_exists() and root.state() == 'withdrawn':
                     print("Final check: Restoring withdrawn window.")
                     root.deiconify()
            except tk.TclError: pass # Window might already be destroyed
            except Exception as final_e: print(f"Error during final restore: {final_e}")

         if root: # Check if root object itself exists
            root.after(200, final_restore) # Schedule with a small delay

# --- auto_grade_action UPDATED to mention Esc key ---
def auto_grade_action():
    """Initiates the auto-grading process."""
    output_file_path = os.path.join(get_data_folder(), "output_grades.txt")
    if not os.path.exists(output_file_path):
         old_path = os.path.join(os.getcwd(), "output_grades.txt")
         if os.path.exists(old_path):
             output_file_path = old_path
             print(f"Using output file from script directory: {output_file_path}")
         else:
             if root and root.winfo_exists(): messagebox.showwarning("Auto Grade", f"'output_grades.txt' not found in data folder '{DATA_SUBFOLDER_NAME}' or script folder.\nRun 'Grade P X' first.", parent=root)
             return

    grades = extract_grades_from_output(output_file_path)
    if grades:
        trigger_msg = "press the '*' key on your keyboard" if keyboard_available else "click OK on the next prompt"
        abort_msg = "(Press ESC to abort typing)" if keyboard_available else ""
        output_fname_display = os.path.basename(output_file_path)
        msg = f"Found {len(grades)} grades in '{output_fname_display}'.\n\n" \
              f"1. Click OK on this message.\n" \
              f"2. Switch to your gradebook window.\n" \
              f"3. Click in the VERY FIRST grade entry field.\n" \
              f"4. THEN {trigger_msg} to begin typing.\n\n" \
              f"   {abort_msg}" # Added Esc info conditionally
        if root and root.winfo_exists():
             root.attributes('-topmost', True)
             messagebox.showinfo("Auto Grade Ready", msg, parent=root)
             root.attributes('-topmost', False)
             # Start typing in a separate thread AFTER user clicks OK
             threading.Thread(target=type_grades, args=(grades,), daemon=True).start()
    else:
        if root and root.winfo_exists(): messagebox.showwarning("Auto Grade", f"No valid grades found in '{os.path.basename(output_file_path)}'.\nEnsure 'Grade P X' was run successfully and produced numeric grades.", parent=root)

# (show_credits, open_gradebook_link, open_data_folder - NO CHANGES)
def show_credits():
    """Displays the credits message box."""
    if root and root.winfo_exists(): messagebox.showinfo("Credits", "DeltaMath Grader\nMade by: Adonis Yanez", parent=root)

def open_gradebook_link():
    """Opens the configured gradebook URL in a web browser."""
    url = CLASS_GRADE_SHEET_URL
    print(f"Opening gradebook link: {url}")
    try:
        webbrowser.open_new_tab(url)
    except Exception as e:
        print(f"Error opening URL '{url}': {e}")
        if root and root.winfo_exists(): messagebox.showerror("Error", f"Could not open the gradebook link:\n{e}", parent=root)

def open_data_folder():
    """Opens the application's data folder in the system's file explorer."""
    data_dir = get_data_folder()
    print(f"Opening data folder: {data_dir}")
    try:
        if sys.platform == "win32":
            os.startfile(data_dir)
        elif sys.platform == "darwin":
            subprocess.Popen(["open", data_dir])
        else:
            subprocess.Popen(["xdg-open", data_dir])
    except FileNotFoundError:
         msg = f"Could not find command to open folder.\nPath: {data_dir}"
         print(f"ERROR: {msg}")
         if root and root.winfo_exists(): messagebox.showerror("Error", msg, parent=root)
    except Exception as e:
         msg = f"Could not open folder:\n{e}\nPath: {data_dir}"
         print(f"ERROR: {msg}")
         if root and root.winfo_exists(): messagebox.showerror("Error", msg, parent=root)

# --- Helper to update Excel Status Label ---
# (update_excel_status_label - updated message slightly)
def update_excel_status_label(text=None):
    """Updates the text of the Excel status label."""
    global excel_filepath
    if not root or 'excel_status_label' not in globals() or not excel_status_label: return
    try:
        if not excel_status_label.winfo_exists(): return
    except tk.TclError: return

    if text:
        new_text = text
    elif excel_filepath and os.path.exists(excel_filepath):
        base_name = os.path.basename(excel_filepath)
        dir_name = os.path.basename(os.path.dirname(excel_filepath))
        if len(base_name) + len(dir_name) > 45:
             display_path = os.path.join("...", dir_name, base_name)
        else:
             display_path = os.path.join(dir_name, base_name)
        new_text = f"Using Excel: {display_path}"
    else:
        new_text = "Click 'Grade Px' to find today's OR Drag & Drop" # Clarified message
    excel_status_label.config(text=new_text)

# --- Drag and Drop Handlers ---
# (on_drag_enter, on_drag_leave, on_drop_excel_file - NO CHANGES)
def on_drag_enter(event):
    """Handles drag enter event for visual feedback."""
    global is_dragging_over
    if event.data and isinstance(event.data, str) and ".xlsx" in event.data.lower():
        is_dragging_over = True
        try:
            if 'left_panel' in globals() and left_panel and left_panel.winfo_exists():
                left_panel.configure(style="Hover.TFrame")
            update_excel_status_label(">>> Release Excel file here <<<")
        except tk.TclError: pass
        except Exception as e: print(f"Error in on_drag_enter: {e}")
        return event.action
    else:
        return event.action

def on_drag_leave(event):
    """Handles drag leave event for visual feedback."""
    global is_dragging_over
    if is_dragging_over:
        is_dragging_over = False
        try:
            if 'left_panel' in globals() and left_panel and left_panel.winfo_exists():
                left_panel.configure(style="TFrame")
            update_excel_status_label()
        except tk.TclError: pass
        except Exception as e: print(f"Error in on_drag_leave: {e}")

def on_drop_excel_file(event):
    """Handles the file drop event to set the Excel file path."""
    global excel_filepath, is_dragging_over, excel_file_source_is_drop
    print(f"Drop detected. Data Type: {type(event.data)}, Raw Data: '{event.data}'")
    was_dragging = is_dragging_over
    is_dragging_over = False
    try:
        if 'left_panel' in globals() and left_panel and left_panel.winfo_exists():
             left_panel.configure(style="TFrame")
    except tk.TclError: pass
    except Exception as e: print(f"Error reverting style on drop: {e}")

    excel_file_found = None
    dropped_items = []
    data_str = event.data
    try:
        if isinstance(data_str, bytes):
            try: data_str = data_str.decode('utf-8')
            except UnicodeDecodeError: data_str = str(data_str)
        if not isinstance(data_str, str): data_str = str(data_str)

        if data_str.strip():
            path_string = data_str.strip().strip('{}')
            print(f"Processing path string: '{path_string}'")
            if path_string:
                try: dropped_items = shlex.split(path_string, posix=(sys.platform != 'win32'))
                except ValueError: dropped_items = [p.strip() for p in path_string.split() if p.strip()]
            else: dropped_items = []

            for item_path in dropped_items:
                cleaned_path = item_path.strip('\'"')
                print(f"Checking dropped item: '{cleaned_path}'")
                try:
                    p = Path(cleaned_path)
                    if p.is_file() and p.suffix.lower() == ".xlsx" and not p.name.startswith('~'):
                        excel_file_found = str(p)
                        print(f"Valid Excel file found: {excel_file_found}")
                        break
                    else: print(f"Item '{cleaned_path}' rejected.")
                except Exception as path_err: print(f"Error checking path '{cleaned_path}': {path_err}")
        else: print("Dropped data was empty after stripping.")
    except Exception as parse_err:
        print(f"Error during drop processing: {parse_err}")
        if root and root.winfo_exists(): messagebox.showerror("Drop Error", f"Could not process dropped item:\n{parse_err}", parent=root)
        if root and root.winfo_exists(): root.after(0, update_excel_status_label)
        return

    if excel_file_found:
        excel_filepath = excel_file_found
        excel_file_source_is_drop = True # <<<--- SET THE FLAG
        print(f"Setting global Excel filepath via DROP: {excel_filepath}")
        if root and root.winfo_exists():
            root.after(0, update_excel_status_label)
            root.after(100, lambda: messagebox.showinfo("Excel File Selected", f"Using dropped Excel file:\n\n{os.path.basename(excel_filepath)}", parent=root))
    else:
        print(f"No valid .xlsx file found in dropped items: {dropped_items}")
        excel_file_source_is_drop = False
        if root and root.winfo_exists():
            if was_dragging: messagebox.showwarning("Invalid File Drop", "Rejected.\nPlease drop only a single, valid Excel (.xlsx) file.", parent=root)
            root.after(0, update_excel_status_label)


# --- In-GUI Text Editor Functions ---
# (load_text_for_editing, on_editor_key_release, save_edited_text_auto - NO CHANGES)
def load_text_for_editing(period_num):
    """Loads the content of a period's name file into the editor."""
    global editor_current_filename
    if 'editor_text' not in globals() or not editor_text: return
    try:
        if not editor_text.winfo_exists() or \
           'editor_status_label' not in globals() or \
           not editor_status_label.winfo_exists(): return
    except tk.TclError: return

    try: editor_text.unbind("<KeyRelease>")
    except tk.TclError: pass

    filepath = get_period_filepath(period_num)
    fname = os.path.basename(filepath)
    try:
        data_folder_path = Path(get_data_folder())
        folder_disp = os.path.join("...", data_folder_path.name)
    except Exception:
        folder_disp = os.path.basename(get_data_folder())

    if not os.path.exists(filepath):
        if save_text_file(filepath, "", show_success=False):
            if root and root.winfo_exists(): messagebox.showinfo("File Created", f"'{fname}' created in:\n{folder_disp}\n\nYou can now add names.", parent=root)
            content = ""
            editor_current_filename = filepath
        else:
            editor_text.config(state=tk.DISABLED)
            editor_status_label.config(text="Editor: Error creating file")
            editor_current_filename = None
            return
    else:
        content = read_text_file(filepath)
        editor_current_filename = filepath

    editor_text.config(state=tk.NORMAL)
    editor_text.delete("1.0", tk.END)
    editor_text.insert(tk.END, content)
    editor_text.edit_reset()
    editor_text.edit_modified(False)
    editor_text.bind("<KeyRelease>", on_editor_key_release)
    editor_status_label.config(text=f"Editing: {fname} (in {folder_disp})")
    editor_text.focus_set()

def on_editor_key_release(event=None):
    """Schedules the auto-save function after a brief delay if text was modified."""
    global editor_save_scheduled
    if 'editor_text' not in globals() or not editor_text: return
    try:
        if not editor_text.winfo_exists(): return
        if editor_text.edit_modified():
             if editor_save_scheduled:
                 try: root.after_cancel(editor_save_scheduled)
                 except ValueError: pass
             if root and root.winfo_exists():
                 editor_save_scheduled = root.after(1000, save_edited_text_auto)
    except tk.TclError: pass

def save_edited_text_auto():
    """Automatically saves the content of the editor to the current file."""
    global editor_save_scheduled
    editor_save_scheduled = None
    if not editor_current_filename: return
    if 'editor_text' not in globals() or not editor_text: return
    try:
        if not editor_text.winfo_exists(): return
        if not editor_text.edit_modified():
             return

        print(f"Auto-saving changes to {os.path.basename(editor_current_filename)}...")
        content = editor_text.get("1.0", tk.END).strip()
        if content: content += "\n"
        if save_text_file(editor_current_filename, content, show_success=False):
             editor_text.edit_modified(False)
        else:
             print(f"ERROR: Auto-save FAILED for {os.path.basename(editor_current_filename)}")
    except tk.TclError: pass
    except Exception as e:
         print(f"ERROR during auto-save: {e}")

# --- Feedback Functions ---
# (send_feedback_request, open_feedback_window, send_feedback_action - NO CHANGES)
def send_feedback_request(feedback_text, feedback_window, send_button):
    """Sends the feedback text to the Discord webhook (runs in a thread)."""
    global root
    if send_button and send_button.winfo_exists():
        root.after(0, lambda: send_button.config(state=tk.DISABLED, text="Sending..."))

    webhook_url = DISCORD_WEBHOOK_URL
    headers = {'Content-Type': 'application/json'}
    timestamp = time.strftime("%Y-%m-%d %H:%M:%S UTC", time.gmtime())
    platform_info = f"OS: {sys.platform}, Python: {sys.version.split()[0]}"
    full_feedback = f"**DeltaMath Grader Feedback ({timestamp}):**\n"
    full_feedback += f"Platform: {platform_info}\n"
    full_feedback += f"```\n{feedback_text}\n```"
    payload = {'content': full_feedback}
    success = False
    error_message = ""

    try:
        print(f"Sending feedback to webhook...")
        response = requests.post(webhook_url, json=payload, headers=headers, timeout=15)
        response.raise_for_status()
        print(f"Feedback sent successfully. Status: {response.status_code}")
        success = True
    except requests.exceptions.Timeout:
        error_message = "Sending feedback timed out. Please check your internet connection."
        print(f"Error sending feedback: {error_message}")
    except requests.exceptions.HTTPError as http_err:
        error_message = f"Feedback failed (HTTP Error): {http_err.response.status_code} {http_err.response.reason}.\nCheck the webhook URL or Discord status."
        print(f"Error sending feedback: {error_message}")
    except requests.exceptions.ConnectionError as conn_err:
         error_message = f"Feedback failed (Connection Error): Could not connect to the server.\n{conn_err}"
         print(f"Error sending feedback: {error_message}")
    except requests.exceptions.RequestException as e:
        error_message = f"Could not send feedback (Request Exception):\n{e}"
        print(f"Error sending feedback: {error_message}")
    except Exception as e:
        error_message = f"An unexpected error occurred while sending feedback:\n{e}"
        print(f"Error sending feedback: {error_message}")

    def update_gui_after_feedback():
        parent_win = None
        if feedback_window and feedback_window.winfo_exists(): parent_win = feedback_window
        elif root and root.winfo_exists(): parent_win = root
        if not parent_win:
            print("Feedback GUI update skipped: No valid parent window.")
            return

        if success:
            messagebox.showinfo("Feedback Sent", "Thank you for your feedback!", parent=parent_win)
            if feedback_window and feedback_window.winfo_exists(): feedback_window.destroy()
        else:
            messagebox.showerror("Feedback Error", error_message, parent=parent_win)
            if send_button and send_button.winfo_exists(): send_button.config(state=tk.NORMAL, text="Send Feedback")

    if root and root.winfo_exists(): root.after(0, update_gui_after_feedback)
    else: print("Root window closed before feedback response could be displayed.")

def open_feedback_window():
    """Opens the feedback submission window."""
    global root, style
    if not requests_available or not DISCORD_WEBHOOK_URL:
        messagebox.showerror("Feature Unavailable", "The feedback feature requires the 'requests' library and a configured webhook.\n(Check installation or console warnings)", parent=root)
        return

    feedback_window = tk.Toplevel(root)
    feedback_window.title("Send Feedback")
    feedback_window.configure(bg=background_color)
    feedback_window.geometry("400x300")
    feedback_window.minsize(350, 250)
    feedback_window.resizable(True, True)
    feedback_window.transient(root)
    feedback_window.grab_set()

    try:
        root_x = root.winfo_rootx(); root_y = root.winfo_rooty()
        root_w = root.winfo_width(); root_h = root.winfo_height()
        win_w = 400; win_h = 300
        x = root_x + (root_w // 2) - (win_w // 2)
        y = root_y + (root_h // 2) - (win_h // 2)
        feedback_window.geometry(f'{win_w}x{win_h}+{x}+{y}')
    except tk.TclError: feedback_window.geometry("400x300")

    feedback_frame = ttk.Frame(feedback_window, padding=15, style="TFrame")
    feedback_frame.pack(fill=tk.BOTH, expand=True)
    instruction_label = ttk.Label(feedback_frame, text="Enter feedback, bug report, or suggestion:", style="Status.TLabel", wraplength=360, justify=tk.LEFT)
    instruction_label.pack(pady=(0, 10), anchor='nw')
    text_area_frame = ttk.Frame(feedback_frame, style="TFrame")
    text_area_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
    text_scrollbar = ttk.Scrollbar(text_area_frame, orient=tk.VERTICAL)
    text_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    feedback_text_widget = tk.Text(text_area_frame, wrap=tk.WORD, height=8,
                                   bg=editor_bg_color, fg=editor_text_color,
                                   font=editor_font, padx=5, pady=5, bd=1, relief=tk.SUNKEN,
                                   yscrollcommand=text_scrollbar.set, undo=True)
    feedback_text_widget.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    text_scrollbar.config(command=feedback_text_widget.yview)
    feedback_text_widget.focus_set()
    send_button = ttk.Button(feedback_frame, text="Send Feedback", style="TButton",
                           command=lambda: send_feedback_action(feedback_text_widget, feedback_window, send_button))
    send_button.pack(pady=(5, 0))
    feedback_window.wait_window()

def send_feedback_action(text_widget, feedback_window, send_button):
    """Gets text and starts the threaded feedback request."""
    feedback_text = text_widget.get("1.0", tk.END).strip()
    if not feedback_text:
        messagebox.showwarning("Empty Feedback", "Please enter your feedback before sending.", parent=feedback_window)
        return
    feedback_thread = threading.Thread(target=send_feedback_request, args=(feedback_text, feedback_window, send_button), daemon=True)
    feedback_thread.start()

# --- UI Setup ---
# (UI layout, styles, widget creation - NO CHANGES)
root = tk_class()
root.title("DeltaMath Grader 2.6")
root.minsize(750, 700)

background_color="#2E2E2E"; button_color="#4CAF50"; button_hover_color="#66BB6A"; text_color="#FFFFFF"; edit_button_color="#03A9F4"; edit_button_hover_color="#29B6F6"; output_bg_color="#3E3E3E"; output_text_color="#E0E0E0"; autograde_button_color="#FFC107"; autograde_button_hover_color="#FFD54F"; title_color="#FFFFFF"; editor_bg_color="#333333"; editor_text_color="#F5F5F5"; status_label_color="#BDBDBD"; link_button_color="#90CAF9"; link_button_hover_color="#BBDEFB"; folder_button_color="#FF9800"; folder_button_hover_color="#FFA726"
hover_bg_color = "#404040"
title_font=("Segoe UI", 20, "bold"); button_font=("Segoe UI", 11, "bold"); edit_button_font=("Segoe UI", 9); output_font=("Consolas", 10); editor_font=("Consolas", 10); status_font=("Segoe UI", 9)

style=ttk.Style()
try: style.theme_use('clam')
except tk.TclError: style.theme_use('default')
style.configure("TFrame", background=background_color)
style.configure("Hover.TFrame", background=hover_bg_color)
style.configure("TLabel", background=background_color, foreground=title_color, font=title_font)
style.configure("Status.TLabel", background=background_color, foreground=status_label_color, font=status_font)
style.configure("TButton", padding=(10, 5), font=button_font, borderwidth=1)
style.map("TButton", foreground=[('!active', text_color), ('active', text_color)], background=[('!active', button_color), ('active', button_hover_color)], relief=[('pressed', 'sunken'), ('!pressed', 'raised')])
style.configure("Edit.TButton", font=edit_button_font, padding=(8, 4))
style.map("Edit.TButton", foreground=[('!active', text_color), ('active', text_color)], background=[('!active', edit_button_color), ('active', edit_button_hover_color)])
style.configure("AutoGrade.TButton", padding=(15, 8))
style.map("AutoGrade.TButton", foreground=[('!active', "#212121"), ('active', "#000000")], background=[('!active', autograde_button_color), ('active', autograde_button_hover_color)])
style.configure("Link.TButton", padding=(10, 5), font=button_font, borderwidth=1)
style.map("Link.TButton", foreground=[('!active', "#0D47A1"), ('active', "#0D47A1")], background=[('!active', link_button_color), ('active', link_button_hover_color)], relief=[('pressed', 'sunken'), ('!pressed', 'raised')])
style.configure("Folder.TButton", padding=(10, 5), font=button_font)
style.map("Folder.TButton", foreground=[('!active', text_color), ('active', text_color)], background=[('!active', folder_button_color), ('active', folder_button_hover_color)], relief=[('pressed', 'sunken'), ('!pressed', 'raised')])
root.configure(bg=background_color)

if tkinterdnd2_available and DND_FILES and hasattr(root, 'drop_target_register'):
    try:
        root.drop_target_register(DND_FILES)
        root.dnd_bind('<<DragEnter>>', on_drag_enter)
        root.dnd_bind('<<DragLeave>>', on_drag_leave)
        root.dnd_bind('<<Drop>>', on_drop_excel_file)
        print("Drag/drop events bound successfully to root window.")
    except tk.TclError as dnd_err:
        print(f"Warning: DND register/bind failed: {dnd_err}")
        if root and root.winfo_exists(): messagebox.showwarning("DND Error", f"Could not initialize drag & drop:\n{dnd_err}", parent=root)
        tkinterdnd2_available = False
else:
    if tkinterdnd2_available: print("Drag/drop skipped (tkinterdnd2 loaded but DND_FILES constant missing or register failed).")
    else: print("Drag/drop bindings skipped (tkinterdnd2 not available).")

paned_window = ttk.PanedWindow(root, orient=tk.HORIZONTAL)
paned_window.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
style.configure("TPanedwindow", background=background_color)
left_panel = ttk.Frame(paned_window, padding=15, style="TFrame")
paned_window.add(left_panel, weight=1)
right_panel = ttk.Frame(paned_window, padding=(0, 15, 15, 15), style="TFrame")
paned_window.add(right_panel, weight=3)
title_label = ttk.Label(left_panel, text="DeltaMath Grader", style="TLabel")
title_label.pack(pady=(0, 15))
excel_status_label = ttk.Label(left_panel, text="Initializing...", style="Status.TLabel", wraplength=left_panel.winfo_reqwidth()-10)
excel_status_label.pack(pady=(0, 15), fill=tk.X)
root.after(50, update_excel_status_label)
periods_frame = ttk.Frame(left_panel, style="TFrame")
periods_frame.pack(fill=tk.X, pady=5)
right_v_pane = ttk.PanedWindow(right_panel, orient=tk.VERTICAL)
right_v_pane.pack(fill=tk.BOTH, expand=True)
style.configure("Vertical.TPanedwindow", background=background_color)
output_frame = ttk.Frame(right_v_pane, style="TFrame", padding=(0, 0, 0, 5))
right_v_pane.add(output_frame, weight=2)
output_label = ttk.Label(output_frame, text="Processing Results:", font=("Segoe UI", 11, "bold"), background=background_color, foreground=output_text_color)
output_label.pack(anchor='nw', pady=(0, 3))
output_text_frame = ttk.Frame(output_frame, style="TFrame")
output_text_frame.pack(fill=tk.BOTH, expand=True)
output_scrollbar = ttk.Scrollbar(output_text_frame, orient=tk.VERTICAL)
output_scrollbar.pack(fill=tk.Y, side=tk.RIGHT)
output_text = tk.Text(output_text_frame, wrap=tk.WORD, bg=output_bg_color, fg=output_text_color, font=output_font, padx=8, pady=5, relief=tk.SUNKEN, bd=1, undo=True, yscrollcommand=output_scrollbar.set, state=tk.DISABLED)
output_text.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)
output_scrollbar.config(command=output_text.yview)
editor_frame = ttk.Frame(right_v_pane, style="TFrame", padding=(0, 5, 0, 0))
right_v_pane.add(editor_frame, weight=1)
editor_status_label = ttk.Label(editor_frame, text="Editor: No File Loaded", font=("Segoe UI", 11, "bold"), background=background_color, foreground=editor_text_color)
editor_status_label.pack(anchor='nw', pady=(0, 3))
editor_text_frame = ttk.Frame(editor_frame, style="TFrame")
editor_text_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 0))
editor_scrollbar = ttk.Scrollbar(editor_text_frame, orient=tk.VERTICAL)
editor_scrollbar.pack(fill=tk.Y, side=tk.RIGHT)
editor_text = tk.Text(editor_text_frame, wrap=tk.WORD, bg=editor_bg_color, fg=editor_text_color, font=editor_font, padx=8, pady=5, relief=tk.SUNKEN, bd=1, undo=True, yscrollcommand=editor_scrollbar.set, state=tk.DISABLED)
editor_text.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)
editor_scrollbar.config(command=editor_text.yview)

def create_period_buttons(parent_frame, period_num, output_widget):
    frame = ttk.Frame(parent_frame, style="TFrame")
    frame.pack(fill=tk.X, pady=3)
    grade_button = ttk.Button(frame, text=f"Grade P{period_num}", command=lambda p=period_num: process_grade_level(p, output_widget), style="TButton")
    grade_button.pack(side=tk.LEFT, expand=True, fill=tk.X, padx=(0, 5))
    edit_button = ttk.Button(frame, text=f"Edit P{period_num}", command=lambda p=period_num: load_text_for_editing(p), style="Edit.TButton")
    edit_button.pack(side=tk.LEFT, padx=(5, 0))

for i in range(1, 9): create_period_buttons(periods_frame, i, output_text)

ttk.Separator(left_panel, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=15)
data_folder_button = ttk.Button(left_panel, text="Open Period Files Folder", command=open_data_folder, style="Folder.TButton")
data_folder_button.pack(pady=(5, 5), fill=tk.X)
gradebook_link_button = ttk.Button(left_panel, text="Class Grade Sheet Page", command=open_gradebook_link, style="Link.TButton")
gradebook_link_button.pack(pady=5, fill=tk.X)
auto_grade_button = ttk.Button(left_panel, text = "Auto Grade (Requires Setup)", command = auto_grade_action, style = "AutoGrade.TButton")
auto_grade_button.pack(pady=5, fill=tk.X)
ttk.Separator(left_panel, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=15)
utility_buttons_frame = ttk.Frame(left_panel, style="TFrame")
utility_buttons_frame.pack(pady=10, fill=tk.X)
feedback_button = ttk.Button(utility_buttons_frame, text="Feedback", command=open_feedback_window, style="Edit.TButton")
feedback_button.pack(side=tk.LEFT, expand=True, fill=tk.X, padx=(0, 5))
credits_button = ttk.Button(utility_buttons_frame, text="Credits", command=show_credits, style="Edit.TButton")
credits_button.pack(side=tk.LEFT, expand=True, fill=tk.X, padx=(5, 0))

# --- Application Exit Handling ---
# (on_closing - NO CHANGES)
def on_closing():
    """Handles application close event."""
    global root, editor_save_scheduled
    print("Close button clicked. Preparing to exit...")
    if editor_save_scheduled:
        try:
            root.after_cancel(editor_save_scheduled)
            print("Cancelled pending auto-save.")
        except Exception: pass

    print("Closing application window.")
    if root:
        try: root.destroy()
        except tk.TclError: print("Window already destroyed.")
        finally: root = None
    sys.exit(0)

root.protocol("WM_DELETE_WINDOW", on_closing)

# --- Excel File Processing Logic ---
# (process_grade_level - Only error message updated)
def process_grade_level(period_num, output_widget):
    """Main logic for processing grades. Now defaults to finding newest excel."""
    global excel_filepath, excel_file_source_is_drop # Access the flag

    current_excel_path = None # Start with no path determined

    # 1. Determine Excel File Path
    if excel_file_source_is_drop and excel_filepath and os.path.exists(excel_filepath):
        print(f"Using recently dropped Excel file: {excel_filepath}")
        current_excel_path = excel_filepath
        excel_file_source_is_drop = False # <<<--- Reset the flag after using it once
    else:
        print(f"Finding Excel files modified today ({date.today()}) in Downloads...") # Mention today
        current_excel_path = find_excel_file_automatically() # Now finds newest/prompts
        if current_excel_path:
            excel_filepath = current_excel_path # Update global path if found
            print(f"Selected/Found today's file: {current_excel_path}")
            if root and root.winfo_exists(): root.after(0, update_excel_status_label) # Update GUI label
        else:
            # find_excel_file_automatically handles showing its own errors if Downloads access failed
            if find_downloads_folder(): # Check if Downloads folder itself was accessible
                 if root and root.winfo_exists():
                     # <<< MODIFIED MESSAGE >>>
                     messagebox.showerror("Error",
                                          "No Excel (.xlsx) files from TODAY found in Downloads,\n"
                                          "or selection was cancelled.\n\n"
                                          "Download a file today OR Drag & Drop.",
                                          parent=root)
            # Reset global path and flag if automatic search fails or is cancelled
            excel_filepath = None
            excel_file_source_is_drop = False
            if root and root.winfo_exists(): root.after(0, update_excel_status_label)
            return # Stop processing if no file is available or selected

    # --- IMPORTANT: Add validation AFTER potential selection ---
    if not current_excel_path or not os.path.exists(current_excel_path):
         msg = f"Selected Excel file not found or is invalid:\n{current_excel_path}\nPlease select a valid file."
         print(f"ERROR: {msg}")
         if root and root.winfo_exists(): messagebox.showerror("Error", msg, parent=root)
         excel_filepath = None
         excel_file_source_is_drop = False
         if root and root.winfo_exists(): root.after(0, update_excel_status_label)
         return

    # 2. Setup File Paths and Display Names
    excel_file_basename = os.path.basename(current_excel_path)
    namelist_filepath = get_period_filepath(period_num)
    namelist_fname = os.path.basename(namelist_filepath)
    try:
        data_folder_path = Path(get_data_folder())
        folder_disp = os.path.join("...", data_folder_path.name)
    except Exception:
        folder_disp = os.path.basename(get_data_folder())

    # 3. Check/Create Name List File
    if not os.path.exists(namelist_filepath):
        if save_text_file(namelist_filepath, "", show_success=False):
            msg = f"Name list '{namelist_fname}' created in:\n{folder_disp}\n\n" \
                  f"Use 'Edit P{period_num}' to add student names (one per line), then run 'Grade P{period_num}' again."
            if root and root.winfo_exists(): messagebox.showinfo("Name List Created", msg, parent=root)
            try:
                output_widget.config(state=tk.NORMAL)
                output_widget.delete("1.0", tk.END)
                output_widget.insert(tk.END, f"-- P{period_num} Halted --\n\nName list '{namelist_fname}' was created.\nAdd names via 'Edit P{period_num}' and run Grade again.")
                output_widget.config(state=tk.DISABLED)
            except tk.TclError: pass
            return
        else:
            return

    # 4. Load Excel Data and Find Name Columns
    parent_win = root if root and root.winfo_exists() else None
    try:
        print(f"Loading Excel data from: {excel_file_basename}")
        df = pd.read_excel(current_excel_path, engine='openpyxl')
        cols_map = {str(c).strip().lower(): str(c).strip() for c in df.columns}
        first_col = cols_map.get("first name") or cols_map.get("first")
        last_col = cols_map.get("last name") or cols_map.get("last")

        missing_name_cols = []
        if not first_col: missing_name_cols.append("'First Name' or 'First'")
        if not last_col: missing_name_cols.append("'Last Name' or 'Last'")
        if missing_name_cols:
            msg = f"Missing required name columns in '{excel_file_basename}':\n{', '.join(missing_name_cols)}.\nPlease ensure the Excel file has these columns."
            if parent_win: messagebox.showerror("Excel Column Error", msg, parent=parent_win)
            excel_filepath = None
            excel_file_source_is_drop = False
            if root and root.winfo_exists(): root.after(0, update_excel_status_label)
            return

        print(f"Found Name Columns: First='{first_col}', Last='{last_col}'")

    except FileNotFoundError:
         msg = f"Excel file disappeared before loading:\n{excel_file_basename}"
         print(f"ERROR: {msg}")
         if parent_win: messagebox.showerror("Excel Read Error", msg, parent=parent_win)
         excel_filepath = None
         excel_file_source_is_drop = False
         if root and root.winfo_exists(): root.after(0, update_excel_status_label)
         return
    except Exception as e:
         msg = f"Error loading data from '{excel_file_basename}':\n{type(e).__name__}: {e}"
         print(f"ERROR: {msg}")
         if parent_win: messagebox.showerror("Excel Read Error", msg, parent=parent_win)
         excel_filepath = None
         excel_file_source_is_drop = False
         if root and root.winfo_exists(): root.after(0, update_excel_status_label)
         return

    # 5. Select Grade Column
    all_column_names_original = [str(c).strip() for c in df.columns]
    target_columns_lower = {'grade', 'complete'}
    selectable_columns = [col for col in all_column_names_original if col.lower() in target_columns_lower]
    print(f"Found potential grade columns ('Grade'/'Complete'): {selectable_columns}")

    selected_grade_col = None
    if not selectable_columns:
        msg = f"Could not find a column named 'Grade' or 'Complete' (case-insensitive) in '{excel_file_basename}'.\nThese are required for grading."
        if parent_win: messagebox.showerror("Excel Column Error", msg, parent=parent_win)
        print("Processing halted due to missing grade column.")
        return
    elif len(selectable_columns) == 1:
        selected_grade_col = selectable_columns[0]
        print(f"Automatically selected grade column: '{selected_grade_col}'")
    else:
        prompt = f"Both 'Grade' and 'Complete' columns (or similar) found in '{excel_file_basename}'.\n\nSelect the column to use for grading:\n\n"
        prompt += "\n".join([f"{i+1}. {col}" for i, col in enumerate(selectable_columns)])
        choice = tkinter.simpledialog.askstring("Select Grade Column", prompt, parent=parent_win)

        if choice is None:
            print("Grade column selection cancelled by user.")
            try:
                output_widget.config(state=tk.NORMAL)
                output_widget.delete("1.0", tk.END)
                output_widget.insert(tk.END, f"-- P{period_num} Cancelled --\n\nUser cancelled grade column selection.")
                output_widget.config(state=tk.DISABLED)
            except tk.TclError: pass
            return

        try:
            idx = int(choice) - 1
            if 0 <= idx < len(selectable_columns):
                selected_grade_col = selectable_columns[idx]
                print(f"User selected grade column: '{selected_grade_col}'")
            else: raise ValueError("Choice out of range")
        except (ValueError, TypeError):
            msg = "Invalid selection. Please enter the number corresponding to the desired column."
            if parent_win: messagebox.showerror("Invalid Input", msg, parent=parent_win)
            print("Processing halted due to invalid grade column selection.")
            return

    # 6. Load Names
    names_to_process = load_names_from_file(namelist_filepath)
    if not names_to_process:
        msg = f"The name list file '{namelist_fname}' is empty.\n\nUse 'Edit P{period_num}' to add student names (one per line), then run 'Grade P{period_num}' again."
        if parent_win: messagebox.showinfo("Empty Name List", msg, parent=parent_win)
        try:
            output_widget.config(state=tk.NORMAL); output_widget.delete("1.0", tk.END)
            output_widget.insert(tk.END, f"-- P{period_num} Halted --\n\nName list '{namelist_fname}' is empty.\nAdd names via 'Edit P{period_num}' and run Grade again.")
            output_widget.config(state=tk.DISABLED)
        except tk.TclError: pass
        return

    # 7. Get Interval Grading Options
    interval_percentage = 50.0
    use_interval = messagebox.askyesno("Grading Option",
                                       f"Apply interval grading based on '{selected_grade_col}'?\n\n"
                                       f"(Example: If threshold is 50%, grades >= 50% become 100%, others become 0%.\n"
                                       f" 'Complete' becomes 100%, other text becomes 0%.)",
                                       parent=parent_win)

    if use_interval:
        valid_input = False
        while not valid_input:
            val_str = tkinter.simpledialog.askstring("Interval Threshold %",
                                                     "Enter the minimum percentage (or equivalent value)\n"
                                                     "required to receive 100%.\n\n(e.g., 50 for 50%):",
                                                     initialvalue=str(int(interval_percentage)),
                                                     parent=parent_win)
            if val_str is None:
                 print("Interval threshold input cancelled by user.")
                 try:
                     output_widget.config(state=tk.NORMAL)
                     output_widget.delete("1.0", tk.END)
                     output_widget.insert(tk.END, f"-- P{period_num} Cancelled --\n\nUser cancelled interval threshold input.")
                     output_widget.config(state=tk.DISABLED)
                 except tk.TclError: pass
                 return

            try:
                pct = float(val_str)
                if 0 <= pct <= 100:
                    interval_percentage = pct
                    valid_input = True
                    print(f"Using Interval Grading with threshold: {interval_percentage}%")
                else:
                    if parent_win: messagebox.showerror("Error", "Percentage must be between 0 and 100.", parent=parent_win)
            except ValueError:
                if parent_win: messagebox.showerror("Error", "Invalid number entered. Please enter a numeric value.", parent=parent_win)
            except Exception as e:
                 if parent_win: messagebox.showerror("Input Error", f"An unexpected error occurred processing input: {e}", parent=parent_win)
                 return

    # 8. Process Names
    output_lines = []
    df_modified = df.copy()
    print(f"\n--- Processing P{period_num} using Grade Column '{selected_grade_col}' ---")
    t_start = time.time()
    processed_count = 0
    not_found_count = 0
    for name in names_to_process:
        if not name.strip(): continue
        result_line = process_name(name, df_modified, first_col, last_col, selected_grade_col,
                                   use_interval, interval_percentage)
        output_lines.append(result_line)
        processed_count +=1
        if "Grade Not Found (No Match)" in result_line:
             not_found_count += 1
    processing_time = time.time() - t_start
    print(f"--- Finished P{period_num} processing {processed_count} names ({not_found_count} not found) in {processing_time:.2f}s ---")

    # 9. Save Output & Update Excel
    output_file_basename = "output_grades.txt"
    output_filepath = os.path.join(get_data_folder(), output_file_basename)

    try:
        with open(output_filepath, 'w', encoding='utf-8') as f_out:
            f_out.write("\n".join(output_lines) + "\n")
        print(f"Processing results written to: {output_filepath}")

        save_msg_parts = [f"Results saved to '{output_file_basename}' (in {folder_disp})."]

        if not df.equals(df_modified):
            print(f"Interval grading modified the DataFrame, attempting to update Excel file...")
            try:
                df_modified.to_excel(current_excel_path, index=False, engine='openpyxl')
                print(f"SUCCESS: Excel file '{excel_file_basename}' updated with interval grades in column '{selected_grade_col}'.")
                save_msg_parts.append(f"Excel '{excel_file_basename}' UPDATED with interval grades (column: '{selected_grade_col}').")
            except PermissionError:
                 msg = f"PERMISSION DENIED saving updated Excel file.\n\nPlease close '{excel_file_basename}' if it's open and try grading again if you want the Excel file updated."
                 print(f"ERROR: {msg}")
                 if parent_win: messagebox.showwarning("Excel Save Warning", msg, parent=parent_win)
                 save_msg_parts.append(f"Excel '{excel_file_basename}' NOT updated (Permission Error - likely open).")
            except Exception as excel_save_err:
                 msg = f"Error saving updated Excel file '{excel_file_basename}':\n{type(excel_save_err).__name__}: {excel_save_err}"
                 print(f"ERROR: {msg}")
                 if parent_win: messagebox.showerror("Excel Save Error", msg, parent=parent_win)
                 save_msg_parts.append(f"Excel '{excel_file_basename}' NOT updated (Save Error).")
        elif use_interval:
             print("Interval grading selected, but no grades were modified in the DataFrame.")
             save_msg_parts.append(f"Interval grading applied, but no grades needed changing in Excel.")

        if parent_win: messagebox.showinfo("Processing Complete", f"Processed P{period_num}.\n\n" + "\n".join(save_msg_parts), parent=parent_win)

        # 10. Update UI Output
        try:
            output_widget.config(state=tk.NORMAL)
            output_widget.delete("1.0", tk.END)
            interval_info = f"On, Threshold={interval_percentage}%" if use_interval else "Off"
            header = f"-- Results P{period_num} --\n"
            header += f"(Excel Source: '{excel_file_basename}')\n"
            header += f"(Name List: '{namelist_fname}')\n"
            header += f"(Grade Column Used: '{selected_grade_col}')\n"
            header += f"(Interval Grading: {interval_info})\n"
            header += f"(Processed {processed_count} names, {not_found_count} not found in {processing_time:.2f}s)\n"
            header += f"{'-'*40}\n"
            output_widget.insert(tk.END, header + "\n".join(output_lines) + "\n")
            output_widget.yview_moveto(0.0)
            output_widget.config(state=tk.DISABLED)
        except tk.TclError: pass

    except PermissionError as perm_err:
        msg = f"PERMISSION DENIED saving '{output_file_basename}'.\nCheck permissions for the data folder:\n{get_data_folder()}\n\nError details: {perm_err}"
        print(f"ERROR: {msg}")
        if parent_win: messagebox.showerror("File Permission Error", msg, parent=parent_win)
    except Exception as e:
        msg = f"An error occurred saving results or updating the display:\n{type(e).__name__}: {e}"
        print(f"ERROR: {msg}")
        if parent_win: messagebox.showerror("Saving/Display Error", msg, parent=parent_win)

    print(f"Finished grading process for P{period_num}.")


# --- Run the Application ---
# (Startup, button state check, mainloop - NO CHANGES)
if __name__ == "__main__":
    print(f"Starting DeltaMath Grader 2.6...")
    print(f"Data folder: {get_data_folder()}")

    def check_and_update_button_states():
        if not root or not root.winfo_exists(): return
        try:
             if 'auto_grade_button' in globals() and auto_grade_button and auto_grade_button.winfo_exists():
                 if not pyautogui_available: auto_grade_button.config(state=tk.DISABLED, text="Auto Grade (Needs pyautogui)")
                 elif not keyboard_available: auto_grade_button.config(state=tk.NORMAL, text="Auto Grade (Click OK to trigger)")
                 else: auto_grade_button.config(state=tk.NORMAL, text="Auto Grade (Press * After Clicking)")
        except tk.TclError: pass
        try:
             if 'feedback_button' in globals() and feedback_button and feedback_button.winfo_exists():
                 if not requests_available or not DISCORD_WEBHOOK_URL: feedback_button.config(state=tk.DISABLED, text="Feedback (Unavailable)")
                 else: feedback_button.config(state=tk.NORMAL, text="Feedback")
        except tk.TclError: pass

    root.after(100, check_and_update_button_states)
    root.after(150, update_excel_status_label)

    try:
        print("Starting Tkinter main loop...")
        root.mainloop()
        print("Tkinter main loop finished.")
    except KeyboardInterrupt:
        print("\nCtrl+C detected. Exiting gracefully.")
        on_closing()
    except Exception as main_err:
        print(f"\n--- UNEXPECTED APPLICATION ERROR ---")
        print(f"{type(main_err).__name__}: {main_err}")
        import traceback
        traceback.print_exc()
        try:
             if root and root.winfo_exists():
                  messagebox.showerror("Fatal Error", f"A critical error occurred:\n{main_err}\n\nSee console for details. The application will close.")
        finally:
             try: on_closing()
             except: pass
