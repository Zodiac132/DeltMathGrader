# -*- coding: utf-8 -*- # Ensure UTF-8 encoding is recognized

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
import tkinter.simpledialog
import os
# import pandas as pd # Defer pandas import for faster startup
from fuzzywuzzy import fuzz
import keyboard # Needed for auto-grade trigger
import pyautogui # Needed for auto-grade typing
import subprocess
import re
import threading
import time
import sys
import shlex # Used for parsing drag/drop paths
import webbrowser # Required to open web links
from pathlib import Path

# --- CORRECTED Import drag and drop library ---
try:
    # Corrected import based on diagnosis:
    # Import the TkinterDnD class *from* the TkinterDnD module within the package
    from tkinterdnd2.TkinterDnD import TkinterDnD
    # Import constants like DND_FILES from the top level of the package
    from tkinterdnd2 import DND_FILES
    tk_class = TkinterDnD # Assign the imported class
    print("tkinterdnd2 found, drag-and-drop enabled.")
except ImportError:
    print("tkinterdnd2 library not found. Drag-and-drop disabled.")
    print("Install using: pip install tkinterdnd2")
    # Import standard tkinter only if DND fails
    import tkinter as tk
    tk_class = tk.Tk # Assign the standard Tk class
    DND_FILES = None # DND_FILES constant is not available
# --- End Corrected Import ---

# --- Configuration ---
CLASS_GRADE_SHEET_URL = "https://gradebook.dadeschools.net/Pinnacle/Gradebook/"
DATA_SUBFOLDER_NAME = "DeltaMathGraderData"

# --- Global Variables ---
excel_filepath = None
editor_current_filename = None
editor_save_scheduled = None
root = None
is_dragging_over = False # Flag for hover state

# --- Helper Functions (get_data_folder, get_period_filepath, etc.) ---
def get_data_folder():
    try:
        home_dir = Path.home()
        possible_docs_paths = [ home_dir / "Documents", home_dir / "My Documents" ]
        docs_dir = next((path for path in possible_docs_paths if path.is_dir()), home_dir)
        if docs_dir == home_dir: print("Warning: Documents folder not found, using home.")
        data_dir = docs_dir / DATA_SUBFOLDER_NAME
        data_dir.mkdir(parents=True, exist_ok=True)
        return str(data_dir)
    except Exception as e:
        messagebox.showerror("Folder Error", f"Could not create/access data folder:\n{e}", parent=root)
        return os.getcwd()

def get_period_filepath(period_num):
    return os.path.join(get_data_folder(), f"period{period_num}.txt")

def load_names_from_file(filepath):
    try:
        with open(filepath, 'r', encoding='utf-8') as f: names = [line.strip() for line in f if line.strip()]
        return names
    except FileNotFoundError: return []
    except Exception as e:
        if root: messagebox.showerror("Error", f"Error reading {os.path.basename(filepath)}:\n{e}", parent=root)
        return []

def read_text_file(filepath):
    try:
        with open(filepath, 'r', encoding='utf-8') as f: return f.read()
    except FileNotFoundError: return ""
    except Exception as e:
        if root: messagebox.showerror("Error", f"Error reading {os.path.basename(filepath)}:\n{e}", parent=root)
        return ""

def save_text_file(filepath, content, show_success=True):
    try:
        os.makedirs(os.path.dirname(filepath), exist_ok=True)
        with open(filepath, 'w', encoding='utf-8') as f: f.write(content)
        if show_success and root:
             display_name = os.path.join("...", DATA_SUBFOLDER_NAME, os.path.basename(filepath))
             # Use lambda to capture current display_name for the delayed message
             root.after(500, lambda name=display_name: messagebox.showinfo("Save Successful", f"Saved {name}", parent=root))
        return True
    except Exception as e:
        error_msg = f"Error saving {os.path.basename(filepath)}:\n{e}"
        print(error_msg)
        if root: messagebox.showerror("Save Error", error_msg, parent=root)
        return False

def find_downloads_folder():
    home = Path.home(); path = home / "Downloads"
    if path.is_dir(): return str(path)
    print("Warning: Could not find Downloads folder."); return None

def find_excel_file_automatically():
    downloads_path = find_downloads_folder()
    if not downloads_path:
        if root: messagebox.showerror("Error", "Could not find Downloads folder.", parent=root); return None
    try:
        excel_files = [ f for f in os.listdir(downloads_path) if os.path.isfile(os.path.join(downloads_path, f)) and f.lower().endswith(".xlsx") and not f.startswith("~") ]
    except Exception as e:
        if root: messagebox.showerror("Error", f"Error reading Downloads: {e}", parent=root); return None
    if not excel_files: return None
    elif len(excel_files) == 1: return os.path.join(downloads_path, excel_files[0])
    else:
        prompt_text = "Multiple Excel files found. Select one:\n\n" + "\n".join([f"{i+1}. {f}" for i, f in enumerate(excel_files)])
        choice = tkinter.simpledialog.askstring("Select Excel File", prompt_text, parent=root)
        try:
            idx = int(choice) - 1
            if 0 <= idx < len(excel_files): return os.path.join(downloads_path, excel_files[idx])
        except (ValueError, TypeError, IndexError): pass # Handle invalid input or cancel
        messagebox.showwarning("Invalid Choice", "No valid file selected.", parent=root); return None

# --- Name Matching / Processing ---
def find_exact_match(name_to_find, df, first_name_column, last_name_column):
    import pandas as pd
    name_lower = name_to_find.lower().strip()
    for index, row in df.iterrows():
        # Ensure conversion to string and handle potential NaN before stripping
        first = str(row.get(first_name_column, '')) if pd.notna(row.get(first_name_column)) else ''
        last = str(row.get(last_name_column, '')) if pd.notna(row.get(last_name_column)) else ''
        full_name = (first.strip() + ' ' + last.strip()).strip()
        if name_lower == full_name.lower(): return row, index
    return None, None

def find_best_match(name_to_find, df, first_name_column, last_name_column, threshold=60):
    import pandas as pd
    best_match_row, best_ratio, best_index = None, 0, None
    name_lower = name_to_find.lower().strip()
    matched_df_name = None # Store the name from the dataframe that matched
    for index, row in df.iterrows():
        first = str(row.get(first_name_column, '')) if pd.notna(row.get(first_name_column)) else ''
        last = str(row.get(last_name_column, '')) if pd.notna(row.get(last_name_column)) else ''
        full_name = (first.strip() + ' ' + last.strip()).strip()
        full_name_lower = full_name.lower()
        if not full_name_lower: continue # Skip empty names in dataframe
        ratio = fuzz.token_sort_ratio(name_lower, full_name_lower)
        if ratio > best_ratio:
            best_ratio, best_match_row, best_index = ratio, row, index
            matched_df_name = full_name # Store the name as found in the df

    if best_ratio >= threshold:
        return best_match_row, best_ratio, best_index, matched_df_name # Return the df name
    return None, 0, None, None

def process_name(name, df, first_col, last_col, grade_col, use_interval, interval_pct):
    import pandas as pd
    exact_row, exact_idx = find_exact_match(name, df, first_col, last_col)
    grade_val, original_grade, match_type, details, target_idx = None, None, "Not Found", "", None
    found_name = name # Default to original name if no match

    if exact_row is not None:
        target_idx = exact_idx
        grade_val = exact_row.get(grade_col)
        match_type = "Exact Match"
        # Construct found name from exact match row
        first = str(exact_row.get(first_col, '')).strip() if pd.notna(exact_row.get(first_col)) else ''
        last = str(exact_row.get(last_col, '')).strip() if pd.notna(exact_row.get(last_col)) else ''
        found_name = f"{first} {last}".strip()
    else:
        match_row, ratio, match_idx, matched_df_name = find_best_match(name, df, first_col, last_col)
        if match_row is not None:
            target_idx = match_idx
            grade_val = match_row.get(grade_col)
            match_type = "Fuzzy Match"
            details = f"(Ratio: {ratio}%)"
            found_name = matched_df_name # Use the name from the matched row

    if pd.notna(grade_val):
        try:
            original_grade = float(grade_val)
            processed_grade = original_grade # Default to original
            if use_interval:
                processed_grade = 100.0 if original_grade >= interval_pct else 0.0
                # Update the dataframe *passed into the function* if interval changed it
                # Ensure target_idx is valid before attempting loc
                if processed_grade != original_grade and target_idx is not None and target_idx in df.index:
                    df.loc[target_idx, grade_col] = processed_grade # Update the DataFrame directly

            orig_str = f"{original_grade:.1f}%" if original_grade is not None else "N/A"
            proc_str = f"{processed_grade:.1f}%" if processed_grade is not None else "N/A"
            # Format: OriginalName -> FoundName | ProcessedGrade (MatchType Details, Original: OrigGrade)
            return f"{name} -> {found_name} | {proc_str} ({match_type} {details}, Original: {orig_str})"
        except (ValueError, TypeError):
            # Format: OriginalName -> FoundName | Invalid Grade (MatchType, Value: 'GradeValue')
            return f"{name} -> {found_name} | Invalid Grade ({match_type}, Value: '{grade_val}')"
    else:
        # Format: OriginalName -> FoundName | Grade Missing (MatchType Details)
        if match_type != "Not Found":
            return f"{name} -> {found_name} | Grade Missing ({match_type} {details})"
        else:
            # Format: OriginalName | Grade Not Found (No Match)
            return f"{name} | Grade Not Found (No Match)"

# --- Grade Typing / Other Utilities ---
def extract_grades_from_output(filepath):
    grades = []
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if not line or '|' not in line: continue # Skip empty or invalid lines
                try:
                    parts = line.split('|')
                    if len(parts) > 1:
                        # Look for the percentage value in the second part
                        percentage_part = parts[1].strip()
                        # Regex to find the first number (integer or float)
                        match = re.match(r"^\s*([\d.]+)", percentage_part)
                        if match:
                            try:
                                grade_float = float(match.group(1))
                                # Format to one decimal place, then remove '.0' if it's an integer
                                formatted_grade = f"{grade_float:.1f}".replace('.0', '')
                                grades.append(formatted_grade)
                            except ValueError:
                                print(f"Warn: Could not convert grade value '{match.group(1)}' to float in line: {line}")
                        else:
                            print(f"Warn: Could not find grade number in second part of line: {line}")
                except Exception as e:
                    print(f"Warn: Error parsing line content: {line} - {e}")
    except FileNotFoundError:
        if root: messagebox.showerror("Error", f"Grade file not found:\n{filepath}", parent=root)
        return []
    except Exception as e:
        if root: messagebox.showerror("Error", f"Error reading grades file:\n{e}", parent=root)
        return []
    return grades

def type_grades(grades_list):
    if not root: return # Check if GUI exists
    if not grades_list:
        if root: messagebox.showwarning("Auto Grade", "No grades extracted to type.", parent=root)
        return

    print("Waiting for '*' key press to start typing...")
    try:
        # Minimize window before waiting, restore after
        root.after(0, root.iconify)
        time.sleep(0.5) # Brief pause to ensure window is minimized
        keyboard.wait('*') # Wait for the trigger key
    except Exception as e:
        if root: messagebox.showerror("Keyboard Error", f"Failed to wait for '*' key:\n{e}\n(Ensure script has permissions if needed)", parent=root)
        try: root.after(0, root.deiconify) # Try to restore window on error
        except tk.TclError: pass # Ignore if window already closed
        return
    finally:
        # Attempt to restore window regardless of wait success/failure, unless root is gone
        try:
            if root and root.winfo_exists():
                 root.after(0, root.deiconify)
                 time.sleep(0.5) # Pause after restoring
        except tk.TclError: pass # Ignore if window closed during wait

    print(f"Detected '*'. Typing {len(grades_list)} grades...")
    try:
        for grade in grades_list:
            # Check if root still exists before typing each grade
            if not root or not root.winfo_exists():
                print("Window closed during typing. Aborting.")
                break
            pyautogui.write(grade, interval=0.01) # Type grade value
            time.sleep(0.05)
            pyautogui.press('enter') # Press Enter to move to next field
            time.sleep(0.15) # Pause between entries
        print("Finished typing grades.")
        if root and root.winfo_exists():
             messagebox.showinfo("Auto Grade", "Finished typing grades.", parent=root)
    except Exception as e:
        print(f"Error during pyautogui typing: {e}")
        if root and root.winfo_exists():
            messagebox.showerror("Typing Error", f"An error occurred during typing:\n{e}", parent=root)

def auto_grade_action():
    output_file_path = os.path.join(get_data_folder(), "output_grades.txt")
    # Check if the output file exists in the data folder
    if not os.path.exists(output_file_path):
         # Fallback: check if it exists in the script's CWD (less ideal)
         old_path = os.path.join(os.getcwd(), "output_grades.txt")
         if os.path.exists(old_path):
             output_file_path = old_path
             print(f"Using output file from script directory: {output_file_path}")
         else:
             if root: messagebox.showwarning("Auto Grade", f"'output_grades.txt' not found in '{DATA_SUBFOLDER_NAME}' or script folder.\nRun 'Grade P X' first.", parent=root)
             return

    grades = extract_grades_from_output(output_file_path)
    if grades:
        msg = f"Found {len(grades)} grades in '{os.path.basename(output_file_path)}'.\n\nClick OK, then focus the first grade field in your gradebook, and finally press the '*' key on your keyboard to begin typing."
        if root: messagebox.showinfo("Auto Grade Ready", msg, parent=root)
        # Run typing in a separate thread to avoid blocking the GUI
        threading.Thread(target=type_grades, args=(grades,), daemon=True).start()
    else:
        if root: messagebox.showwarning("Auto Grade", f"No valid grades found in '{os.path.basename(output_file_path)}'.", parent=root)

def show_credits():
    if root: messagebox.showinfo("Credits", "Made by: Adonis Yanez", parent=root)

def open_gradebook_link():
    url = CLASS_GRADE_SHEET_URL
    print(f"Opening gradebook link: {url}")
    try:
        webbrowser.open_new_tab(url)
    except Exception as e:
        print(f"Error opening URL with webbrowser: {e}")
        if root: messagebox.showerror("Error", f"Could not open the gradebook link:\n{e}", parent=root)

def open_data_folder():
    data_dir = get_data_folder()
    print(f"Opening data folder: {data_dir}")
    try:
        # Use platform-specific commands for opening folders
        if sys.platform == "win32":
            os.startfile(data_dir) # Preferred way on Windows
        elif sys.platform == "darwin": # macOS
            subprocess.Popen(["open", data_dir])
        else: # Linux/other Unix-like
            subprocess.Popen(["xdg-open", data_dir])
    except FileNotFoundError:
         if root: messagebox.showerror("Error", f"Could not find command to open folder.\nPath: {data_dir}", parent=root)
    except Exception as e:
         if root: messagebox.showerror("Error", f"Could not open folder:\n{e}\nPath: {data_dir}", parent=root)


# --- Helper to update Excel Status Label ---
def update_excel_status_label(text=None):
    # Ensure root and label exist before trying to update
    if not root or 'excel_status_label' not in globals() or not excel_status_label: return
    # Check if label widget still exists
    if not excel_status_label.winfo_exists(): return

    if text: # Use provided text directly
        new_text = text
    elif excel_filepath and os.path.exists(excel_filepath):
        # Show basename if a valid path is set
        new_text = f"Using Excel: {os.path.basename(excel_filepath)}"
    else:
        # Default prompt
        new_text = "Drag & Drop Excel file OR place in Downloads"
    excel_status_label.config(text=new_text)

# --- Drag and Drop Handlers ---
def on_drag_enter(event):
    global is_dragging_over
    print("Drag Enter detected")
    is_dragging_over = True
    try:
        # Check if left_panel exists before configuring
        if 'left_panel' in globals() and left_panel and left_panel.winfo_exists():
            left_panel.configure(style="Hover.TFrame")
        # Use helper to update label, avoid direct config if label might not exist yet
        update_excel_status_label(">>> Release file here <<<")
    except Exception as e: # Catch potential TclError or NameError
        print(f"Error applying hover style/text: {e}")

def on_drag_leave(event):
    global is_dragging_over
    # Only revert if we were actually dragging over
    if is_dragging_over:
        print("Drag Leave detected")
        is_dragging_over = False
        try:
            if 'left_panel' in globals() and left_panel and left_panel.winfo_exists():
                left_panel.configure(style="TFrame") # Revert to default style
            # Reset label to show actual current state using helper
            update_excel_status_label()
        except Exception as e:
            print(f"Error reverting style/text: {e}")

# Use the refined on_drop_excel_file function from previous step
def on_drop_excel_file(event):
    global excel_filepath, is_dragging_over
    print(f"Drop detected. Event Type: {type(event.data)}, Raw Data: '{event.data}'") # More detailed log

    # --- Revert Visual Feedback Immediately ---
    was_dragging = is_dragging_over # Store if we were actually hovering
    is_dragging_over = False
    try:
        if 'left_panel' in globals() and left_panel and left_panel.winfo_exists():
             left_panel.configure(style="TFrame")
    except Exception as e: print(f"Error reverting style on drop: {e}")

    # --- Process Dropped Data ---
    excel_file_found = None
    dropped_items = [] # Use a more generic name
    data_str = event.data

    try:
        # Attempt to convert to string if not already (handles bytes, etc. cautiously)
        if not isinstance(data_str, str):
            try: data_str = str(data_str, encoding='utf-8') # Try decoding if bytes
            except TypeError: data_str = str(data_str) # Fallback to basic string conversion
            print(f"Converted event.data to string: '{data_str}'")

        if data_str.strip():
            # Remove potential surrounding braces first (common from Windows Explorer)
            path_string = data_str.strip().strip('{}')
            print(f"Processing path string: '{path_string}'")

            # Use shlex for robust parsing (handles spaces, quotes)
            try:
                # Use posix=False on Windows for backslash compatibility
                # Handle potential empty string after stripping braces
                if path_string:
                    dropped_items = shlex.split(path_string, posix=(sys.platform != 'win32'))
                else:
                    dropped_items = []
                print(f"Parsed dropped items via shlex: {dropped_items}")
            except ValueError as shex:
                # Fallback: Basic split (less reliable for paths with spaces)
                print(f"shlex parsing failed ({shex}), trying basic split.")
                if path_string: # Avoid splitting empty string
                    dropped_items = [p.strip() for p in path_string.split()]
                else:
                    dropped_items = []
                print(f"Parsed dropped items via basic split: {dropped_items}")

            if not dropped_items:
                print("Parsing resulted in no file paths.")

            # --- Validate Files ---
            # Find the first *valid* .xlsx file among potentially multiple dropped items
            for item_path in dropped_items:
                # Clean up path just in case (remove extra quotes if shlex didn't)
                cleaned_path = item_path.strip('\'"')
                print(f"Checking dropped item: '{cleaned_path}'")
                try:
                    # Use Path object for robust checking
                    p = Path(cleaned_path)
                    if p.is_file() and p.suffix.lower() == ".xlsx" and not p.name.startswith('~'):
                        excel_file_found = str(p) # Convert back to string for consistency
                        print(f"Valid Excel file found: {excel_file_found}")
                        break # Stop after finding the first valid one
                    else:
                         print(f"Item '{cleaned_path}' validation failed (Exists: {p.exists()}, IsFile: {p.is_file()}, SuffixOK: {p.suffix.lower() == '.xlsx'}, NameOK: {not p.name.startswith('~')})")
                except Exception as path_err:
                     print(f"Error checking path '{cleaned_path}': {path_err}")
        else:
             print("Dropped data resulted in empty string.")

    except Exception as parse_err:
        print(f"Error during drop processing: {parse_err}")
        import traceback
        traceback.print_exc() # Print full traceback for parsing errors
        if root: messagebox.showerror("Drop Error", f"Could not process dropped item:\n{parse_err}", parent=root)
        # Ensure label is reset even after error
        if root: root.after(0, update_excel_status_label)
        return # Stop processing on error

    # --- Update based on validation result ---
    if excel_file_found:
        excel_filepath = excel_file_found
        print(f"Setting global Excel filepath: {excel_filepath}")
        # Update the status label and show confirmation
        if root:
            root.after(0, update_excel_status_label) # Use helper via after()
            messagebox.showinfo("Excel File Selected",
                                f"Using Excel file:\n\n{os.path.basename(excel_filepath)}",
                                parent=root)
    else:
        # No valid excel file found in the drop
        print(f"No valid .xlsx file found in dropped items: {dropped_items}")
        # Show warning *only if* something was actually dragged/dropped and parsing yielded items
        if root and (was_dragging or dropped_items): # Check if there was intent or items parsed
            messagebox.showwarning("Invalid File Drop",
                                   "Rejected.\nPlease drop only a single, valid Excel (.xlsx) file.",
                                   parent=root)
        # Reset label to show the previous or default state
        if root: root.after(0, update_excel_status_label)


# --- In-GUI Text Editor Functions ---
def load_text_for_editing(period_num):
    global editor_current_filename
    # Ensure editor widget exists
    if 'editor_text' not in globals() or not editor_text or not editor_text.winfo_exists(): return

    editor_text.unbind("<KeyRelease>") # Unbind first to prevent issues
    filepath = get_period_filepath(period_num)
    fname = os.path.basename(filepath)
    folder_disp = os.path.join("...", DATA_SUBFOLDER_NAME)

    if not os.path.exists(filepath):
        # Try creating the file if it doesn't exist
        if save_text_file(filepath, "", show_success=False):
            if root: messagebox.showinfo("File Created", f"'{fname}' created in:\n{folder_disp}", parent=root)
            content = ""
            editor_current_filename = filepath
        else:
            # If creation failed, disable editor and show error status
            editor_text.config(state=tk.DISABLED)
            if 'editor_status_label' in globals() and editor_status_label.winfo_exists():
                 editor_status_label.config(text="Editor: Error creating file")
            return
    else:
        # File exists, read its content
        content = read_text_file(filepath)
        editor_current_filename = filepath

    # Enable editor, clear old content, insert new content
    editor_text.config(state=tk.NORMAL)
    editor_text.delete("1.0", tk.END)
    editor_text.insert(tk.END, content)
    editor_text.bind("<KeyRelease>", on_editor_key_release) # Rebind key release
    # Update status label
    if 'editor_status_label' in globals() and editor_status_label.winfo_exists():
        editor_status_label.config(text=f"Editing: {fname} (in {folder_disp})")

def on_editor_key_release(event=None):
    # Schedule the save slightly delayed to avoid saving on every single keystroke instantly
    global editor_save_scheduled
    if editor_save_scheduled:
        root.after_cancel(editor_save_scheduled)
    editor_save_scheduled = root.after(1000, save_edited_text_auto) # Save after 1 sec of inactivity

def save_edited_text_auto():
    global editor_save_scheduled
    editor_save_scheduled = None # Clear schedule flag
    if not editor_current_filename: return
    # Ensure editor exists before getting text
    if 'editor_text' not in globals() or not editor_text or not editor_text.winfo_exists(): return

    content = editor_text.get("1.0", tk.END).strip() # Get content and remove trailing/leading whitespace
    # Add a newline only if there's content, ensures empty files stay empty
    if content: content += "\n"
    save_text_file(editor_current_filename, content, show_success=False) # Save silently


# --- UI Setup ---
# Use tk_class which was determined during import (TkinterDnD or tk.Tk)
root = tk_class()
root.title("DeltaMath Grader 2.3") # Version Bump
root.minsize(750, 700) # Set minimum window size

# --- Colors, Fonts, Styles ---
background_color="#2E2E2E"; button_color="#4CAF50"; button_hover_color="#66BB6A"; text_color="#FFFFFF"; edit_button_color="#03A9F4"; edit_button_hover_color="#29B6F6"; output_bg_color="#3E3E3E"; output_text_color="#E0E0E0"; autograde_button_color="#FFC107"; autograde_button_hover_color="#FFD54F"; title_color="#FFFFFF"; editor_bg_color="#333333"; editor_text_color="#F5F5F5"; status_label_color="#BDBDBD"; link_button_color="#90CAF9"; link_button_hover_color="#BBDEFB"; folder_button_color="#FF9800"; folder_button_hover_color="#FFA726"
hover_bg_color = "#404040" # Hover indication color
title_font=("Segoe UI", 20, "bold"); button_font=("Segoe UI", 11, "bold"); edit_button_font=("Segoe UI", 9); output_font=("Consolas", 10); editor_font=("Consolas", 10); status_font=("Segoe UI", 9)
style=ttk.Style();
try: style.theme_use('clam') # Clam theme often looks better if available
except tk.TclError: style.theme_use('default') # Fallback theme
# Configure base styles
style.configure("TFrame", background=background_color)
style.configure("Hover.TFrame", background=hover_bg_color) # Style for hover state (used for DND feedback)
style.configure("TLabel", background=background_color, foreground=title_color, font=title_font); style.configure("Status.TLabel", background=background_color, foreground=status_label_color, font=status_font); style.configure("TButton", padding=(10, 5), font=button_font, borderwidth=1); style.map("TButton", foreground=[('!active', text_color), ('active', text_color)], background=[('!active', button_color), ('active', button_hover_color)], relief=[('pressed', 'sunken'), ('!pressed', 'raised')]); style.configure("Edit.TButton", font=edit_button_font, padding=(8, 4)); style.map("Edit.TButton", foreground=[('!active', text_color), ('active', text_color)], background=[('!active', edit_button_color), ('active', edit_button_hover_color)]); style.configure("AutoGrade.TButton", padding=(15, 8)); style.map("AutoGrade.TButton", foreground=[('!active', "#212121"), ('active', "#000000")], background=[('!active', autograde_button_color), ('active', autograde_button_hover_color)]); style.configure("Link.TButton", padding=(10, 5), font=button_font, borderwidth=1); style.map("Link.TButton", foreground=[('!active', "#0D47A1"), ('active', "#0D47A1")], background=[('!active', link_button_color), ('active', link_button_hover_color)], relief=[('pressed', 'sunken'), ('!pressed', 'raised')]); style.configure("Folder.TButton", padding=(10, 5), font=button_font); style.map("Folder.TButton", foreground=[('!active', text_color), ('active', text_color)], background=[('!active', folder_button_color), ('active', folder_button_hover_color)], relief=[('pressed', 'sunken'), ('!pressed', 'raised')])
# Apply background color to the root window itself
root.configure(bg=background_color)

# --- Drag and Drop Setup ---
# Check if DND_FILES is available (meaning tkinterdnd2 likely loaded)
# and if the root window object supports drop target registration
if DND_FILES and hasattr(root, 'drop_target_register'):
    try:
        root.drop_target_register(DND_FILES) # Register for file drops
        # Bind specific drag events to the handlers defined earlier
        root.dnd_bind('<<DragEnter>>', on_drag_enter)
        root.dnd_bind('<<DragLeave>>', on_drag_leave)
        root.dnd_bind('<<Drop>>', on_drop_excel_file)
        print("Drag/drop events bound to root window.")
    except tk.TclError as dnd_err:
        print(f"Warning: DND register/bind failed: {dnd_err}")
        if root: messagebox.showwarning("DND Error", f"Could not initialize drag & drop:\n{dnd_err}", parent=root)
else:
    print("Drag/drop disabled (tkinterdnd2 likely not available or failed).")


# --- Main Layout Frames ---
# Paned window allows resizing between left/right panels
paned_window = ttk.PanedWindow(root, orient=tk.HORIZONTAL)
paned_window.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
style.configure("TPanedwindow", background=background_color) # Style the sash

# Left panel (controls)
# Apply default style initially, hover style applied by DND handlers
left_panel = ttk.Frame(paned_window, padding=15, style="TFrame")
paned_window.add(left_panel, weight=1) # Weight determines relative size

# Right panel (output/editor)
right_panel = ttk.Frame(paned_window, padding=15, style="TFrame")
paned_window.add(right_panel, weight=3) # Give right panel more initial space

# --- Left Panel Widgets ---
title_label = ttk.Label(left_panel, text="DeltaMath Grader", style="TLabel")
title_label.pack(pady=(0, 15)) # Padding below title

# Status label for Excel file status
excel_status_label = ttk.Label(left_panel, text="Initializing...", style="Status.TLabel")
excel_status_label.pack(pady=(0, 15), fill=tk.X) # Fill horizontally
# Schedule initial update slightly after window appears
root.after(50, update_excel_status_label)

# Frame to hold period buttons
periods_frame = ttk.Frame(left_panel, style="TFrame")
periods_frame.pack(fill=tk.X, pady=5)

# --- Right Panel Widgets ---
# Vertical paned window for splitting Output and Editor areas
right_v_pane = ttk.PanedWindow(right_panel, orient=tk.VERTICAL)
right_v_pane.pack(fill=tk.BOTH, expand=True)
style.configure("Vertical.TPanedwindow", background=background_color) # Style sash

# Output Area Frame
output_frame = ttk.Frame(right_v_pane, style="TFrame", padding=(0, 0, 0, 5))
right_v_pane.add(output_frame, weight=2) # Output gets more initial space

output_label = ttk.Label(output_frame, text="Processing Results:", font=("Segoe UI", 11, "bold"), background=background_color, foreground=output_text_color)
output_label.pack(anchor='nw', pady=(0, 3)) # Align label top-left

output_text_frame = ttk.Frame(output_frame, style="TFrame")
output_text_frame.pack(fill=tk.BOTH, expand=True)
output_scrollbar = ttk.Scrollbar(output_text_frame, orient=tk.VERTICAL)
output_scrollbar.pack(fill=tk.Y, side=tk.RIGHT)
output_text = tk.Text(output_text_frame, wrap=tk.WORD, bg=output_bg_color, fg=output_text_color, font=output_font, padx=8, pady=5, relief=tk.SUNKEN, bd=1, undo=True, yscrollcommand=output_scrollbar.set)
output_text.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)
output_scrollbar.config(command=output_text.yview)

# Editor Area Frame
editor_frame = ttk.Frame(right_v_pane, style="TFrame", padding=(0, 5, 0, 0))
right_v_pane.add(editor_frame, weight=1) # Editor gets less initial space

editor_status_label = ttk.Label(editor_frame, text="Editor: No File Loaded", font=("Segoe UI", 11, "bold"), background=background_color, foreground=editor_text_color)
editor_status_label.pack(anchor='nw', pady=(0, 3)) # Align label top-left

editor_text_frame = ttk.Frame(editor_frame, style="TFrame")
editor_text_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 5))
editor_scrollbar = ttk.Scrollbar(editor_text_frame, orient=tk.VERTICAL)
editor_scrollbar.pack(fill=tk.Y, side=tk.RIGHT)
editor_text = tk.Text(editor_text_frame, wrap=tk.WORD, bg=editor_bg_color, fg=editor_text_color, font=editor_font, padx=8, pady=5, relief=tk.SUNKEN, bd=1, undo=True, yscrollcommand=editor_scrollbar.set)
editor_text.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)
editor_scrollbar.config(command=editor_text.yview)
# Start editor disabled until a file is loaded
editor_text.config(state=tk.DISABLED)

# --- Period Buttons ---
def create_period_buttons(parent_frame, period_num, output_widget):
    frame = ttk.Frame(parent_frame, style="TFrame")
    frame.pack(fill=tk.X, pady=3)
    # Grade button calls process_grade_level with period number
    grade_button = ttk.Button(frame, text=f"Grade P{period_num}",
                             command=lambda p=period_num: process_grade_level(p, output_widget),
                             style="TButton")
    grade_button.pack(side=tk.LEFT, expand=True, fill=tk.X, padx=(0, 5))
    # Edit button calls load_text_for_editing with period number
    edit_button = ttk.Button(frame, text=f"Edit P{period_num}",
                            command=lambda p=period_num: load_text_for_editing(p),
                            style="Edit.TButton")
    edit_button.pack(side=tk.LEFT, padx=(5, 0))

# Create buttons for periods 1 through 8
for i in range(1, 9):
    create_period_buttons(periods_frame, i, output_text)

# --- Spacers and Bottom Buttons ---
ttk.Separator(left_panel, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=15)

data_folder_button = ttk.Button(left_panel, text="Open Period Files Folder", command=open_data_folder, style="Folder.TButton")
data_folder_button.pack(pady=(5, 5), fill=tk.X)

gradebook_link_button = ttk.Button(left_panel, text="Class Grade Sheet Page", command=open_gradebook_link, style="Link.TButton")
gradebook_link_button.pack(pady=5, fill=tk.X)

auto_grade_button = ttk.Button(left_panel, text = "Auto Grade (Press * After Clicking)", command = auto_grade_action, style = "AutoGrade.TButton")
auto_grade_button.pack(pady=5, fill=tk.X)

ttk.Separator(left_panel, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=15)

# Frame for Help/Credits buttons at the bottom
help_credits_frame = ttk.Frame(left_panel, style="TFrame")
help_credits_frame.pack(pady=10, fill=tk.X)

credits_button = ttk.Button(help_credits_frame, text="Credits", command=show_credits, style="Edit.TButton")
credits_button.pack(side=tk.LEFT, expand=True, fill=tk.X)

# --- Final Setup ---
# Disable output text initially, enable only when adding text
output_text.config(state=tk.DISABLED)

# --- Application Exit Handling ---
def on_closing():
    print("Closing application...")
    # Optional: Perform any cleanup here if needed (e.g., saving unsaved changes)
    # get_data_folder() # Calling this here doesn't do much unless needed for cleanup path
    if root: root.destroy() # Destroy the main window

# Assign the closing handler to the window's close button (X)
root.protocol("WM_DELETE_WINDOW", on_closing)

# --- Excel File Processing Logic ---
def process_grade_level(period_num, output_widget):
    global excel_filepath # Use the global path set by DND or find_excel_file_automatically
    current_excel_path = excel_filepath # Work with a local copy for this run

    # 1. Check if a valid Excel path is already set
    if not current_excel_path or not os.path.exists(current_excel_path):
        print("No valid Excel file set or path invalid, searching Downloads...")
        current_excel_path = find_excel_file_automatically()
        if current_excel_path:
            excel_filepath = current_excel_path # Update global path if found
            if root: root.after(0, update_excel_status_label) # Update label via helper
        else:
            if root: messagebox.showerror("Error", "No Excel file selected.\nDrag & drop an .xlsx file or place one in Downloads.", parent=root)
            return # Stop if no file found

    # 2. Double-check the path after potential auto-find
    if not current_excel_path or not os.path.exists(current_excel_path):
         if root: messagebox.showerror("Error", f"Excel file still not found or invalid:\n{current_excel_path}", parent=root)
         # Reset global path if the current attempt failed with it
         if excel_filepath == current_excel_path: excel_filepath = None
         if root: root.after(0, update_excel_status_label)
         return

    # 3. Import pandas (only when needed) and load Excel
    try: import pandas as pd
    except ImportError:
        if root: messagebox.showerror("Import Error", "Library 'pandas' not found.\nPlease ensure it's installed:\npip install pandas", parent=root)
        return

    excel_file_basename = os.path.basename(current_excel_path)
    namelist_filepath = get_period_filepath(period_num)
    namelist_fname = os.path.basename(namelist_filepath)
    folder_disp = os.path.join("...", DATA_SUBFOLDER_NAME) # For display messages

    # 4. Check/Create Name List File
    if not os.path.exists(namelist_filepath):
        if save_text_file(namelist_filepath, "", show_success=False):
            msg = f"'{namelist_fname}' created in:\n{folder_disp}\n\nEdit this file (use 'Edit P{period_num}') to add names before grading."
            if root: messagebox.showinfo("File Created", msg, parent=root)
            # Update output widget to inform user
            output_widget.config(state=tk.NORMAL)
            output_widget.delete("1.0", tk.END)
            output_widget.insert(tk.END, f"-- P{period_num} Results --\n\nName list '{namelist_fname}' created.\nAdd names via 'Edit P{period_num}' and Grade again.")
            output_widget.config(state=tk.DISABLED)
            return # Stop processing, user needs to add names
        else:
            if root: messagebox.showerror("Error", f"Could not create '{namelist_fname}'. Check permissions.", parent=root)
            return

    # 5. Load Excel Data and check required columns
    try:
        df = pd.read_excel(current_excel_path)
        # Create a mapping of lower-case column names to original case for flexibility
        cols = {str(c).strip().lower(): str(c).strip() for c in df.columns}
        first_col = cols.get("first name") # Check common variations
        if not first_col: first_col = cols.get("first")
        last_col = cols.get("last name")
        if not last_col: last_col = cols.get("last")
        grade_col = cols.get("grade") # Assuming 'Grade' is the target column

        # Check if essential columns were found
        if not all([first_col, last_col, grade_col]):
            missing = []
            if not first_col: missing.append("'First Name'/'First'")
            if not last_col: missing.append("'Last Name'/'Last'")
            if not grade_col: missing.append("'Grade'")
            msg = f"Missing required columns in '{excel_file_basename}':\n{', '.join(missing)}."
            if root: messagebox.showerror("Excel Column Error", msg, parent=root)
            return
    except FileNotFoundError:
         if root: messagebox.showerror("Excel Error", f"Excel file not found during read:\n{current_excel_path}", parent=root)
         return
    except Exception as e:
         if root: messagebox.showerror("Excel Read Error", f"Error loading data from '{excel_file_basename}':\n{e}", parent=root)
         return

    # 6. Load Names from the period file
    names_to_process = load_names_from_file(namelist_filepath)
    if not names_to_process:
        if root: messagebox.showinfo("Info", f"Name list '{namelist_fname}' is empty.\nAdd names using 'Edit P{period_num}' and try grading again.", parent=root)
        # Update output widget
        output_widget.config(state=tk.NORMAL); output_widget.delete("1.0", tk.END)
        output_widget.insert(tk.END, f"-- P{period_num} Results --\n(No names found in {namelist_fname})")
        output_widget.config(state=tk.DISABLED); return

    # 7. Get Grading Options (Interval Grading)
    use_interval = messagebox.askyesno("Grading Option", "Apply interval grading?\n(e.g., >= 50% becomes 100%, < 50% becomes 0%)", parent=root)
    interval_percentage = 50.0 # Default threshold
    if use_interval:
        valid_input = False
        while not valid_input:
            val_str = tkinter.simpledialog.askstring("Interval Threshold %", "Enter minimum percentage required to get 100% (e.g., 50):", initialvalue=str(int(interval_percentage)), parent=root)
            if val_str is None: return # User cancelled the dialog
            try:
                pct = float(val_str)
                if 0 <= pct <= 100:
                    interval_percentage = pct
                    valid_input = True
                else:
                    if root: messagebox.showerror("Error", "Percentage must be between 0 and 100.", parent=root)
            except ValueError:
                if root: messagebox.showerror("Error", "Invalid number entered.", parent=root)
            except Exception as e: # Catch other potential errors
                 if root: messagebox.showerror("Input Error", f"An unexpected error occurred: {e}", parent=root)
                 return # Exit if unexpected error during input

    # 8. Process Names and Generate Output
    output_lines = []
    df_modified = df.copy() # Work on a copy of the DataFrame for potential modifications
    print(f"\n--- Processing P{period_num} using '{excel_file_basename}' ---")
    t_start = time.time()
    for name in names_to_process:
        # Pass df_modified so interval changes can be applied *before* saving
        result_line = process_name(name, df_modified, first_col, last_col, grade_col, use_interval, interval_percentage)
        output_lines.append(result_line)
    print(f"--- Finished P{period_num} processing in {time.time() - t_start:.2f}s ---")

    # 9. Save Output File and potentially the Modified Excel File
    output_file = "output_grades.txt"
    output_filepath = os.path.join(get_data_folder(), output_file)
    output_fname = os.path.basename(output_filepath)
    try:
        # Save the text output results
        with open(output_filepath, 'w', encoding='utf-8') as f_out:
            f_out.write("\n".join(output_lines) + "\n")
        print(f"Processing results written to: {output_filepath}")

        save_msg_parts = [f"Results saved to '{output_fname}' (in {folder_disp})."]

        # Save the Excel file back *only* if interval grading was used and modified the DataFrame
        # Check if the modified DataFrame is different from the original
        if use_interval and not df_modified.equals(df):
            try:
                df_modified.to_excel(current_excel_path, index=False)
                print(f"Excel file '{excel_file_basename}' updated with interval grades.")
                save_msg_parts.append(f"Excel '{excel_file_basename}' UPDATED with interval grades.")
            except PermissionError:
                 # Specific error if Excel file is open
                 msg = f"PERMISSION DENIED saving updated Excel file.\nPlease close '{excel_file_basename}' if it's open and try again."
                 if root: messagebox.showerror("Excel Save Error", msg, parent=root)
                 # Still show results were saved to text file
                 save_msg_parts.append(f"Excel '{excel_file_basename}' NOT updated (Permission Error).")
            except Exception as excel_save_err:
                 msg = f"Error saving updated Excel file '{excel_file_basename}':\n{excel_save_err}"
                 if root: messagebox.showerror("Excel Save Error", msg, parent=root)
                 save_msg_parts.append(f"Excel '{excel_file_basename}' NOT updated (Save Error).")
        else:
            save_msg_parts.append(f"Excel '{excel_file_basename}' NOT modified.")

        # Show success message combining results
        if root: messagebox.showinfo("Success", f"Processed P{period_num}.\n\n" + "\n".join(save_msg_parts), parent=root)

        # 10. Update UI Output Text Area
        output_widget.config(state=tk.NORMAL)
        output_widget.delete("1.0", tk.END)
        # Create a header for the output
        interval_info = f"On, Threshold={interval_percentage}%" if use_interval else "Off"
        header = f"-- Results P{period_num} --\n"
        header += f"(Using Excel: '{excel_file_basename}')\n"
        header += f"(Using Names: '{namelist_fname}')\n"
        header += f"(Interval Grading: {interval_info})\n\n"
        output_widget.insert(tk.END, header + "\n".join(output_lines) + "\n")
        output_widget.config(state=tk.DISABLED) # Disable editing

    except PermissionError as perm_err:
        # General permission error (might be output file or Excel read/write)
        msg = f"PERMISSION DENIED.\nCheck permissions for folder:\n{get_data_folder()}\nAnd file:\n{current_excel_path}\n\nError details: {perm_err}"
        if root: messagebox.showerror("File Permission Error", msg, parent=root)
    except Exception as e:
        # Catch any other errors during saving/UI update
        if root: messagebox.showerror("Saving/Display Error", f"An error occurred saving results or updating display:\n{e}", parent=root)


# --- Run the Application ---
if __name__ == "__main__":
    print(f"Starting Yanez DELTA GOD 2.3...")
    print(f"Ensuring data folder exists: {get_data_folder()}") # Create data folder on startup

    # Check if optional dependencies for Auto Grade are installed
    auto_grade_enabled = True
    try: import pyautogui
    except ImportError:
        print("WARN: Optional library 'pyautogui' missing, Auto Grade feature disabled.")
        auto_grade_enabled = False
    try: import keyboard
    except ImportError:
        print("WARN: Optional library 'keyboard' missing, Auto Grade trigger ('*') might not work.")
        # Auto-grade might still partially work if pyautogui is present, but trigger is manual

    # Function to disable the button if dependencies are missing
    def check_and_disable_button():
        # Check if button exists before configuring
        if not auto_grade_enabled and 'auto_grade_button' in globals() and auto_grade_button and auto_grade_button.winfo_exists():
            auto_grade_button.config(state=tk.DISABLED, text="Auto Grade (Disabled - Missing Libs)")
            print("Auto Grade button disabled due to missing dependencies.")

    # Schedule the check after the main window elements are created
    root.after(100, check_and_disable_button)

    try:
        print("Starting Tkinter main loop...")
        root.mainloop() # Start the GUI event loop
    except KeyboardInterrupt:
        print("\nCtrl+C detected. Exiting.")
        on_closing() # Call cleanup function on interrupt
    except Exception as main_err:
        # Catch unexpected errors during mainloop execution
        print(f"\n--- UNEXPECTED APPLICATION ERROR ---")
        print(f"{type(main_err).__name__}: {main_err}")
        import traceback
        traceback.print_exc() # Print full traceback
        # Attempt graceful exit if possible
        try: on_closing()
        except: pass # Ignore errors during cleanup after main error
